<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>The TokTok Project - Tox specification</title>
    <link rel="stylesheet" type="text/css" media="screen" href="css/main.css">
    <link rel="stylesheet" type="text/css" media="screen" href="css/rust.css">
  </head>
  <body>
    <nav id="sidemenu">
      <ul class="nav tree">
<li><a href="index.html">Home</a></li>
<li><a href="mission.html">Mission</a></li>
<li><a href="roadmap.html">Roadmap</a></li>
<li><a href="vision.html">Long term vision</a></li>
<li class="current"><a href="spec.html">Tox specification</a></li>
<li><a href="development.html">Development process</a></li>
<li><a href="designs.html">Designs</a></li>
</ul>
    </nav>

    <div id="content">

      <h1 class="title">Tox specification</h1>

      <nav id="toc"><ul>
<li>
<a id="toc-introduction" href="#introduction"><span class="header-section-number">1</span> Introduction</a><ul>
<li><a id="toc-integers" href="#integers"><span class="header-section-number">1.1</span> Integers</a></li>
<li><a id="toc-strings" href="#strings"><span class="header-section-number">1.2</span> Strings</a></li>
</ul>
</li>
<li>
<a id="toc-crypto" href="#crypto"><span class="header-section-number">2</span> Crypto</a><ul>
<li><a id="toc-text" href="#text"><span class="header-section-number">2.1</span> Text</a></li>
<li><a id="toc-key" href="#key"><span class="header-section-number">2.2</span> Key</a></li>
<li><a id="toc-box" href="#box"><span class="header-section-number">2.3</span> Box</a></li>
</ul>
</li>
<li>
<a id="toc-node-info" href="#node-info"><span class="header-section-number">3</span> Node Info</a><ul>
<li><a id="toc-transport-protocol" href="#transport-protocol"><span class="header-section-number">3.1</span> Transport Protocol</a></li>
<li><a id="toc-host-address" href="#host-address"><span class="header-section-number">3.2</span> Host Address</a></li>
<li><a id="toc-port-number" href="#port-number"><span class="header-section-number">3.3</span> Port Number</a></li>
<li><a id="toc-socket-address" href="#socket-address"><span class="header-section-number">3.4</span> Socket Address</a></li>
<li><a id="toc-node-info-packed-node-format" href="#node-info-packed-node-format"><span class="header-section-number">3.5</span> Node Info (packed node format)</a></li>
</ul>
</li>
<li>
<a id="toc-protocol-packet" href="#protocol-packet"><span class="header-section-number">4</span> Protocol Packet</a><ul><li><a id="toc-packet-kind" href="#packet-kind"><span class="header-section-number">4.1</span> Packet Kind</a></li></ul>
</li>
<li>
<a id="toc-dht" href="#dht"><span class="header-section-number">5</span> DHT</a><ul>
<li><a id="toc-distance" href="#distance"><span class="header-section-number">5.1</span> Distance</a></li>
<li><a id="toc-k-buckets" href="#k-buckets"><span class="header-section-number">5.2</span> K-buckets</a></li>
<li><a id="toc-dht-node-state" href="#dht-node-state"><span class="header-section-number">5.3</span> DHT node state</a></li>
<li><a id="toc-self-organisation" href="#self-organisation"><span class="header-section-number">5.4</span> Self-organisation</a></li>
<li><a id="toc-dht-packet" href="#dht-packet"><span class="header-section-number">5.5</span> DHT Packet</a></li>
<li><a id="toc-rpc-services" href="#rpc-services"><span class="header-section-number">5.6</span> RPC Services</a></li>
<li><a id="toc-dht-request-packets" href="#dht-request-packets"><span class="header-section-number">5.7</span> DHT Request packets</a></li>
<li><a id="toc-hole-punching" href="#hole-punching"><span class="header-section-number">5.8</span> Hole punching</a></li>
</ul>
</li>
<li>
<a id="toc-lan-discovery" href="#lan-discovery"><span class="header-section-number">6</span> LAN discovery</a><ul></ul>
</li>
<li>
<a id="toc-messenger" href="#messenger"><span class="header-section-number">7</span> Messenger</a><ul>
<li><a id="toc-online" href="#online"><span class="header-section-number">7.1</span> <code>ONLINE</code></a></li>
<li><a id="toc-offline" href="#offline"><span class="header-section-number">7.2</span> <code>OFFLINE</code></a></li>
<li><a id="toc-nickname" href="#nickname"><span class="header-section-number">7.3</span> <code>NICKNAME</code></a></li>
<li><a id="toc-statusmessage" href="#statusmessage"><span class="header-section-number">7.4</span> <code>STATUSMESSAGE</code></a></li>
<li><a id="toc-userstatus" href="#userstatus"><span class="header-section-number">7.5</span> <code>USERSTATUS</code></a></li>
<li><a id="toc-typing" href="#typing"><span class="header-section-number">7.6</span> <code>TYPING</code></a></li>
<li><a id="toc-message" href="#message"><span class="header-section-number">7.7</span> <code>MESSAGE</code></a></li>
<li><a id="toc-action" href="#action"><span class="header-section-number">7.8</span> <code>ACTION</code></a></li>
<li><a id="toc-msi" href="#msi"><span class="header-section-number">7.9</span> <code>MSI</code></a></li>
<li><a id="toc-file-transfer-related-packets" href="#file-transfer-related-packets"><span class="header-section-number">7.10</span> File Transfer Related Packets</a></li>
<li><a id="toc-group-chat-related-packets" href="#group-chat-related-packets"><span class="header-section-number">7.11</span> Group Chat Related Packets</a></li>
</ul>
</li>
<li>
<a id="toc-tcp-client" href="#tcp-client"><span class="header-section-number">8</span> TCP client</a><ul></ul>
</li>
<li>
<a id="toc-tcp-connections" href="#tcp-connections"><span class="header-section-number">9</span> TCP connections</a><ul></ul>
</li>
<li>
<a id="toc-tcp-server" href="#tcp-server"><span class="header-section-number">10</span> TCP server</a><ul><li><a id="toc-encrypted-payload-types" href="#encrypted-payload-types"><span class="header-section-number">10.1</span> Encrypted payload types</a></li></ul>
</li>
<li>
<a id="toc-friend-connection" href="#friend-connection"><span class="header-section-number">11</span> Friend connection</a><ul></ul>
</li>
<li>
<a id="toc-friend-requests" href="#friend-requests"><span class="header-section-number">12</span> Friend requests</a><ul></ul>
</li>
<li>
<a id="toc-group" href="#group"><span class="header-section-number">13</span> Group</a><ul><li><a id="toc-message-ids" href="#message-ids"><span class="header-section-number">13.1</span> Message ids</a></li></ul>
</li>
<li>
<a id="toc-net-crypto" href="#net-crypto"><span class="header-section-number">14</span> Net crypto</a><ul></ul>
</li>
<li>
<a id="toc-network.txt" href="#network.txt"><span class="header-section-number">15</span> network.txt</a><ul></ul>
</li>
<li>
<a id="toc-onion" href="#onion"><span class="header-section-number">16</span> Onion</a><ul></ul>
</li>
<li>
<a id="toc-ping-array" href="#ping-array"><span class="header-section-number">17</span> Ping array</a><ul></ul>
</li>
<li>
<a id="toc-state-format" href="#state-format"><span class="header-section-number">18</span> State Format</a><ul><li><a id="toc-sections" href="#sections"><span class="header-section-number">18.1</span> Sections</a></li></ul>
</li>
<li>
<a id="toc-test-protocol" href="#test-protocol"><span class="header-section-number">19</span> Test protocol</a><ul>
<li><a id="toc-basic-data-encoding" href="#basic-data-encoding"><span class="header-section-number">19.1</span> Basic data encoding</a></li>
<li><a id="toc-deconstructed-values" href="#deconstructed-values"><span class="header-section-number">19.2</span> Deconstructed values</a></li>
<li><a id="toc-test-names" href="#test-names"><span class="header-section-number">19.3</span> Test names</a></li>
<li><a id="toc-result" href="#result"><span class="header-section-number">19.4</span> Result</a></li>
</ul>
</li>
</ul></nav>
        <a href="#introduction"><h1 id="introduction">
<span class="header-section-number">1</span> Introduction</h1></a>
<p><a id="introduction-1" href="#introduction-1" class="paragraph">1</a>This document is a textual specification of the Tox protocol and all the supporting modules required to implement it. The goal of this document is to give enough guidance to permit a complete and correct implementation of the protocol.</p>
<p><a id="introduction-2" href="#introduction-2" class="paragraph">2</a>All data types are defined before their first use, and their binary protocol representation is given. The protocol representations are normative and must be implemented exactly as specified. For some types, human-readable representations are suggested. An implementation may choose to provide no such representation or a different one. The implementation is free to choose any in-memory representation of the specified types, as long as they can be encoded to and decoded from the specified protocol representation.</p>
<p><a id="introduction-3" href="#introduction-3" class="paragraph">3</a>Binary formats are specified in tables with length, type, and content descriptions. If applicable, specific enumeration types are used, so types may be self-explanatory in some cases. The length can be either a fixed number in bytes (e.g. <code>32</code>), a number in bits (e.g. <code>7</code> bit), a choice of lengths (e.g. <code>4 | 16</code>), or an inclusive range (e.g. <code>[0, 100]</code>). Open ranges are denoted <code>[n,]</code> to mean a minimum length of <code>n</code> with no specified maximum length.</p>
<a href="#integers"><h2 id="integers">
<span class="header-section-number">1.1</span> Integers</h2></a>
<p><a id="integers-1" href="#integers-1" class="paragraph">1</a>The protocol uses four bounded unsigned integer types. Bounded means they have a upper bound beyond which incrementing is not defined. The integer types support modular arithmetic, so overflow wraps around to zero. Unsigned means their lower bound is 0. Signed integer types are not used. The binary encoding of all integer types is a fixed-width byte sequence with the integer encoded in <a href="https://en.wikipedia.org/wiki/Endianness">Big Endian</a> unless stated otherwise.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type name</th>
<th style="text-align: left;">C type</th>
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Upper bound</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Word8</td>
<td style="text-align: left;"><code>uint8_t</code></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">255 (0xff)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Word16</td>
<td style="text-align: left;"><code>uint16_t</code></td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">65535 (0xffff)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Word32</td>
<td style="text-align: left;"><code>uint32_t</code></td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">4294967295 (0xffffffff)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Word64</td>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">18446744073709551615 (0xffffffffffffffff)</td>
</tr>
</tbody>
</table>
<a href="#strings"><h2 id="strings">
<span class="header-section-number">1.2</span> Strings</h2></a>
<p><a id="strings-1" href="#strings-1" class="paragraph">1</a>A String is a data structure used for human readable text. Strings are sequences of glyphs. A glyph consists of one non-zero-width unicode code point and zero or more zero-width unicode code points. The human-readable representation of a String starts and ends with a quotation mark (<code>"</code>) and contains all human-readable glyphs verbatim. Control characters are represented in an isomorphic human-readable way. I.e. every control character has exactly one human-readable representation, and a mapping exists from the human-readable representation to the control character. Therefore, the use of Unicode Control Characters (U+240x) is not permitted without additional marker.</p>
<a href="#crypto"><h1 id="crypto">
<span class="header-section-number">2</span> Crypto</h1></a>
<p><a id="crypto-1" href="#crypto-1" class="paragraph">1</a>The Crypto module contains all the functions and data types related to cryptography. This includes random number generation, encryption and decryption, key generation, operations on nonces and generating random nonces.</p>
<a href="#text"><h2 id="text">
<span class="header-section-number">2.1</span> Text</h2></a>
<p><a id="text-1" href="#text-1" class="paragraph">1</a>The Tox protocol differentiates between two types of text: Plain Text and Cipher Text. Cipher Text may be transmitted over untrusted data channels. Plain Text can be Sensitive or Non Sensitive. Sensitive Plain Text must be transformed into Cipher Text using the encryption function before it can be transmitted over untrusted data channels.</p>
<a href="#key"><h2 id="key">
<span class="header-section-number">2.2</span> Key</h2></a>
<p><a id="key-1" href="#key-1" class="paragraph">1</a>A Crypto Number is a large fixed size unsigned (positive) integer. Its binary encoding is as a Big Endian integer in exactly the encoded byte size. Its human-readable encoding is as a base-16 number encoded as String. The NaCl implementation <a href="https://github.com/jedisct1/libsodium">libsodium</a> supplies the functions <code>sodium_bin2hex</code> and <code>sodium_hex2bin</code> to aid in implementing the human-readable encoding. The in-memory encoding of these crypto numbers in NaCl already satisfies the binary encoding, so for applications directly using those APIs, binary encoding and decoding is the <a href="https://en.wikipedia.org/wiki/Identity_function">identity function</a>.</p>
<p><a id="key-2" href="#key-2" class="paragraph">2</a>Tox uses four kinds of Crypto Numbers:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Bits</th>
<th style="text-align: left;">Encoded byte size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">256</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="even">
<td style="text-align: left;">Secret Key</td>
<td style="text-align: left;">256</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Combined Key</td>
<td style="text-align: left;">256</td>
<td style="text-align: left;">32</td>
</tr>
<tr class="even">
<td style="text-align: left;">Nonce</td>
<td style="text-align: left;">192</td>
<td style="text-align: left;">24</td>
</tr>
</tbody>
</table>
<a href="#key-pair"><h3 id="key-pair">
<span class="header-section-number">2.2.1</span> Key Pair</h3></a>
<p><a id="key-pair-1" href="#key-pair-1" class="paragraph">1</a>A Key Pair is a pair of Secret Key and Public Key. A new key pair is generated using the <code>crypto_box_keypair</code> function of the NaCl crypto library. Two separate calls to the key pair generation function must return distinct key pairs. See the <a href="https://nacl.cr.yp.to/box.html">NaCl documentation</a> for details.</p>
<p><a id="key-pair-2" href="#key-pair-2" class="paragraph">2</a>A Public Key can be computed from a Secret Key using the NaCl function <code>crypto_scalarmult_base</code>, which computes the scalar product of a standard group element and the Secret Key. See the <a href="https://nacl.cr.yp.to/scalarmult.html">NaCl documentation</a> for details.</p>
<a href="#combined-key"><h3 id="combined-key">
<span class="header-section-number">2.2.2</span> Combined Key</h3></a>
<p><a id="combined-key-1" href="#combined-key-1" class="paragraph">1</a>A Combined Key is computed from a Secret Key and a Public Key using the NaCl function <code>crypto_box_beforenm</code>. Given two Key Pairs KP1 (SK1, PK1) and KP2 (SK2, PK1), the Combined Key computed from (SK1, PK2) equals the one computed from (SK2, PK1). This allows for symmetric encryption, as peers can derive the same shared key from their own secret key and their peer’s public key.</p>
<p><a id="combined-key-2" href="#combined-key-2" class="paragraph">2</a>In the Tox protocol, packets are encrypted using the public key of the receiver and the secret key of the sender. The receiver decrypts the packets using the receiver’s secret key and the sender’s public key.</p>
<p><a id="combined-key-3" href="#combined-key-3" class="paragraph">3</a>The fact that the same key is used to encrypt and decrypt packets on both sides means that packets being sent could be replayed back to the sender if there is nothing to prevent it.</p>
<p><a id="combined-key-4" href="#combined-key-4" class="paragraph">4</a>The shared key generation is the most resource intensive part of the encryption/decryption which means that resource usage can be reduced considerably by saving the shared keys and reusing them later as much as possible.</p>
<a href="#nonce"><h3 id="nonce">
<span class="header-section-number">2.2.3</span> Nonce</h3></a>
<p><a id="nonce-1" href="#nonce-1" class="paragraph">1</a>A random nonce is generated using the cryptographically secure random number generator from the NaCl library <code>randombytes</code>.</p>
<p><a id="nonce-2" href="#nonce-2" class="paragraph">2</a>A nonce is incremented by interpreting it as a Big Endian number and adding 1. If the nonce has the maximum value, the value after the increment is 0.</p>
<p><a id="nonce-3" href="#nonce-3" class="paragraph">3</a>Most parts of the protocol use random nonces. This prevents new nonces from being associated with previous nonces. If many different packets could be tied together due to how the nonces were generated, it might for example lead to tying DHT and onion announce packets together. This would introduce a flaw in the system as non friends could tie some people’s DHT keys and long term keys together.</p>
<a href="#box"><h2 id="box">
<span class="header-section-number">2.3</span> Box</h2></a>
<p><a id="box-1" href="#box-1" class="paragraph">1</a>The encryption function takes a Combined Key, a Nonce, and a Plain Text, and returns a Cipher Text. It uses <code>crypto_box_afternm</code> to perform the encryption. The meaning of the sentence “encrypting with a secret key, a public key, and a nonce” is: compute a combined key from the secret key and the public key and then use the encryption function for the transformation.</p>
<p><a id="box-2" href="#box-2" class="paragraph">2</a>The decryption function takes a Combined Key, a Nonce, and a Cipher Text, and returns either a Plain Text or an error. It uses <code>crypto_box_open_afternm</code> from the NaCl library. Since the cipher is symmetric, the encryption function can also perform decryption, but will not perform message authentication, so the implementation must be careful to use the correct functions.</p>
<p><a id="box-3" href="#box-3" class="paragraph">3</a><code>crypto_box</code> uses xsalsa20 symmetric encryption and poly1305 authentication.</p>
<p><a id="box-4" href="#box-4" class="paragraph">4</a>The create and handle request functions are the encrypt and decrypt functions for a type of DHT packets used to send data directly to other DHT nodes. To be honest they should probably be in the DHT module but they seem to fit better here. TODO: What exactly are these functions?</p>
<a href="#node-info"><h1 id="node-info">
<span class="header-section-number">3</span> Node Info</h1></a>
<a href="#transport-protocol"><h2 id="transport-protocol">
<span class="header-section-number">3.1</span> Transport Protocol</h2></a>
<p><a id="transport-protocol-1" href="#transport-protocol-1" class="paragraph">1</a>A Transport Protocol is a transport layer protocol directly below the Tox protocol itself. Tox supports two transport protocols: UDP and TCP. The binary representation of the Transport Protocol is a single bit: 0 for UDP, 1 for TCP. If encoded as standalone value, the bit is stored in the least significant bit of a byte. If followed by other bit-packed data, it consumes exactly one bit.</p>
<p><a id="transport-protocol-2" href="#transport-protocol-2" class="paragraph">2</a>The human-readable representation for UDP is <code>UDP</code> and for TCP is <code>TCP</code>.</p>
<a href="#host-address"><h2 id="host-address">
<span class="header-section-number">3.2</span> Host Address</h2></a>
<p><a id="host-address-1" href="#host-address-1" class="paragraph">1</a>A Host Address is either an IPv4 or an IPv6 address. The binary representation of an IPv4 address is a Big Endian 32 bit unsigned integer (4 bytes). For an IPv6 address, it is a Big Endian 128 bit unsigned integer (16 bytes). The binary representation of a Host Address is a 7 bit unsigned integer specifying the address family (2 for IPv4, 10 for IPv6), followed by the address itself.</p>
<p><a id="host-address-2" href="#host-address-2" class="paragraph">2</a>Thus, when packed together with the Transport Protocol, the first bit of the packed byte is the protocol and the next 7 bits are the address family.</p>
<a href="#port-number"><h2 id="port-number">
<span class="header-section-number">3.3</span> Port Number</h2></a>
<p><a id="port-number-1" href="#port-number-1" class="paragraph">1</a>A Port Number is a 16 bit number. Its binary representation is a Big Endian 16 bit unsigned integer (2 bytes).</p>
<a href="#socket-address"><h2 id="socket-address">
<span class="header-section-number">3.4</span> Socket Address</h2></a>
<p><a id="socket-address-1" href="#socket-address-1" class="paragraph">1</a>A Socket Address is a pair of Host Address and Port Number. Together with a Transport Protocol, it is sufficient information to address a network port on any internet host.</p>
<a href="#node-info-packed-node-format"><h2 id="node-info-packed-node-format">
<span class="header-section-number">3.5</span> Node Info (packed node format)</h2></a>
<p><a id="node-info-packed-node-format-1" href="#node-info-packed-node-format-1" class="paragraph">1</a>The Node Info data structure contains a Transport Protocol, a Socket Address, and a Public Key. This is sufficient information to start communicating with that node. The binary representation of a Node Info is called the “packed node format”.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<code>1</code> bit</td>
<td style="text-align: left;">Transport Protocol</td>
<td style="text-align: left;">UDP = 0, TCP = 1</td>
</tr>
<tr class="even">
<td style="text-align: left;">
<code>7</code> bit</td>
<td style="text-align: left;">Address Family</td>
<td style="text-align: left;">2 = IPv4, 10 = IPv6</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>4 | 16</code></td>
<td style="text-align: left;">IP address</td>
<td style="text-align: left;">4 bytes for IPv4, 16 bytes for IPv6</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">Port Number</td>
<td style="text-align: left;">Port number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Node ID</td>
</tr>
</tbody>
</table>
<p><a id="node-info-packed-node-format-2" href="#node-info-packed-node-format-2" class="paragraph">2</a>The packed node format is a way to store the node info in a small yet easy to parse format. To store more than one node, simply append another one to the previous one: <code>[packed node 1][packed node 2][...]</code>.</p>
<p><a id="node-info-packed-node-format-3" href="#node-info-packed-node-format-3" class="paragraph">3</a>In the packed node format, the first byte (high bit protocol, lower 7 bits address family) are called the IP Type. The following table is informative and can be used to simplify the implementation.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">IP Type</th>
<th style="text-align: left;">Transport Protocol</th>
<th style="text-align: left;">Address Family</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>2 (0x02)</code></td>
<td style="text-align: left;">UDP</td>
<td style="text-align: left;">IPv4</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>10 (0x0a)</code></td>
<td style="text-align: left;">UDP</td>
<td style="text-align: left;">IPv6</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>130 (0x82)</code></td>
<td style="text-align: left;">TCP</td>
<td style="text-align: left;">IPv4</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>138 (0x8a)</code></td>
<td style="text-align: left;">TCP</td>
<td style="text-align: left;">IPv6</td>
</tr>
</tbody>
</table>
<p><a id="node-info-packed-node-format-4" href="#node-info-packed-node-format-4" class="paragraph">4</a>The number <code>130</code> is used for an IPv4 TCP relay and <code>138</code> is used to indicate an IPv6 TCP relay.</p>
<p><a id="node-info-packed-node-format-5" href="#node-info-packed-node-format-5" class="paragraph">5</a>The reason for these numbers is because the numbers on Linux for IPv4 and IPv6 (the <code>AF_INET</code> and <code>AF_INET6</code> defines) are <code>2</code> and <code>10</code>. The TCP numbers are just the UDP numbers <code>+ 128</code>.</p>
<a href="#protocol-packet"><h1 id="protocol-packet">
<span class="header-section-number">4</span> Protocol Packet</h1></a>
<p><a id="protocol-packet-1" href="#protocol-packet-1" class="paragraph">1</a>A Protocol Packet is the top level Tox protocol element. All other packet types are wrapped in Protocol Packets. It consists of a Packet Kind and a payload. The binary representation of a Packet Kind is a single byte (8 bits). The payload is an arbitrary sequence of bytes.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Packet Kind</td>
<td style="text-align: left;">The packet kind identifier</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;">Bytes</td>
<td style="text-align: left;">Payload</td>
</tr>
</tbody>
</table>
<p><a id="protocol-packet-2" href="#protocol-packet-2" class="paragraph">2</a>These top level packets can be transported in a number of ways, the most common way being over the network using UDP or TCP. The protocol itself does not prescribe transport methods, and an implementation is free to implement additional transports such as WebRTC, IRC, or pipes.</p>
<p><a id="protocol-packet-3" href="#protocol-packet-3" class="paragraph">3</a>In the remainder of the document, different kinds of Protocol Packet are specified with their packet kind and payload. The packet kind is not repeated in the payload description (TODO: actually it mostly is, but later it won’t).</p>
<p><a id="protocol-packet-4" href="#protocol-packet-4" class="paragraph">4</a>Inside Protocol Packets payload, other packet types can specify additional packet kinds. E.g. inside a Crypto Data packet (<code>0x1b</code>), the <a href="#messenger">Messenger</a> module defines its protocols for messaging, file transfers, etc. Top level Protocol Packets are themselves not encrypted, though their payload may be.</p>
<a href="#packet-kind"><h2 id="packet-kind">
<span class="header-section-number">4.1</span> Packet Kind</h2></a>
<p><a id="packet-kind-1" href="#packet-kind-1" class="paragraph">1</a>The following is an exhaustive list of top level packet kind names and their number. Their payload is specified in dedicated sections. Each section is named after the Packet Kind it describes followed by the byte value in parentheses, e.g. <a href="#ping-request-0x00">Ping Request (0x00)</a>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Byte value</th>
<th style="text-align: left;">Packet Kind</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0x00</code></td>
<td style="text-align: left;">Ping Request</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x01</code></td>
<td style="text-align: left;">Ping Response</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x02</code></td>
<td style="text-align: left;">Nodes Request</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x04</code></td>
<td style="text-align: left;">Nodes Response</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x18</code></td>
<td style="text-align: left;">Cookie Request</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x19</code></td>
<td style="text-align: left;">Cookie Response</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x1a</code></td>
<td style="text-align: left;">Crypto Handshake</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x1b</code></td>
<td style="text-align: left;">Crypto Data</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x20</code></td>
<td style="text-align: left;">DHT Request</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x21</code></td>
<td style="text-align: left;">LAN Discovery</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x80</code></td>
<td style="text-align: left;">Onion Request 0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x81</code></td>
<td style="text-align: left;">Onion Request 1</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x82</code></td>
<td style="text-align: left;">Onion Request 2</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x83</code></td>
<td style="text-align: left;">Announce Request</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x84</code></td>
<td style="text-align: left;">Announce Response</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x85</code></td>
<td style="text-align: left;">Onion Data Request</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x86</code></td>
<td style="text-align: left;">Onion Data Response</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x8c</code></td>
<td style="text-align: left;">Onion Response 3</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>0x8d</code></td>
<td style="text-align: left;">Onion Response 2</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>0x8e</code></td>
<td style="text-align: left;">Onion Response 1</td>
</tr>
</tbody>
</table>
<a href="#dht"><h1 id="dht">
<span class="header-section-number">5</span> DHT</h1></a>
<p><a id="dht-1" href="#dht-1" class="paragraph">1</a>The DHT is a self-organizing swarm of all nodes in the Tox network. A node in the Tox network is also called “Tox node”. When we talk about “peers”, we mean any node that is not the local node (the subject). This module takes care of finding the IP and port of nodes and establishing a route to them directly via UDP using <a href="#hole-punching">hole punching</a> if necessary. The DHT only runs on UDP and so is only used if UDP works.</p>
<p><a id="dht-2" href="#dht-2" class="paragraph">2</a>Every node in the Tox DHT has an ephemeral Key Pair called the DHT Key Pair consisting of the DHT Secret Key and the DHT Public Key. The DHT Public Key acts as the node address. The DHT Key Pair is renewed every time the tox instance is closed or restarted. An implementation may choose to renew the key more often, but doing so will disconnect all peers.</p>
<p><a id="dht-3" href="#dht-3" class="paragraph">3</a>The DHT public key of a friend is found using the <a href="#onion">onion</a> module. Once the DHT public key of a friend is known, the DHT is used to find them and connect directly to them via UDP.</p>
<a href="#distance"><h2 id="distance">
<span class="header-section-number">5.1</span> Distance</h2></a>
<p><a id="distance-1" href="#distance-1" class="paragraph">1</a>A Distance is a positive integer. Its human-readable representation is a base-16 number. Distance is an <a href="https://en.wikipedia.org/wiki/Ordered_semigroup">ordered monoid</a> with the associative binary operator <code>+</code> and the identity element <code>0</code>. When we speak of a “close node”, we mean that their Distance to the node under consideration is small compared to the Distance to other nodes.</p>
<p><a id="distance-2" href="#distance-2" class="paragraph">2</a>The DHT needs a <a href="https://en.wikipedia.org/wiki/Metric_(mathematics)">metric</a> to determine distance between two nodes. The Distance type is the co-domain of this metric. The metric currently used by the Tox DHT is the <code>XOR</code> of the nodes’ public keys. The public keys are interpreted as Big Endian integers (see <a href="#key-1">Crypto Numbers</a>).</p>
<p><a id="distance-3" href="#distance-3" class="paragraph">3</a>An implementation is not required to provide a Distance type, so it has no specified binary representation. For example, instead of computing a distance and comparing it against another distance, the implementation can choose to implement Distance as a pair of public keys and define an ordering on Distance without computing the complete integral value. This works, because as soon as an ordering decision can be made in the most significant bits, further bits won’t influence that decision.</p>
<p><a id="distance-4" href="#distance-4" class="paragraph">4</a>The XOR metric <code>d</code> satisfies the required conditions:</p>
<ol type="1">
<li>Non-negativity <code>d(x, y) &gt;= 0</code>: Since public keys are Crypto Numbers, which are by definition positive, their XOR is necessarily positive.</li>
<li>Identity of indiscernibles <code>d(x, y) == 0</code> iff <code>x == y</code>: The XOR of two integers is zero iff they are equal.</li>
<li>Symmetry <code>d(x, y) == d(y, x)</code>: XOR is a symmetric operation.</li>
<li>Subadditivity <code>d(x, z) &lt;= d(x, y) + d(y, z)</code>: TODO.</li>
</ol>
<p><a id="distance-5" href="#distance-5" class="paragraph">5</a>Example: Given three nodes with keys 2, 5, and 6:</p>
<ul>
<li><code>2 XOR 5 = 7</code></li>
<li><code>2 XOR 6 = 4</code></li>
<li><code>5 XOR 2 = 7</code></li>
<li><code>5 XOR 6 = 3</code></li>
<li><code>6 XOR 2 = 4</code></li>
<li><code>6 XOR 5 = 3</code></li>
</ul>
<p><a id="distance-6" href="#distance-6" class="paragraph">6</a>The closest node from both 2 and 5 is 6. The closest node from 6 is 5 with distance 3. This example shows that a key that is close in terms of integer addition may not necessarily be close in terms of XOR.</p>
<a href="#k-buckets"><h2 id="k-buckets">
<span class="header-section-number">5.2</span> K-buckets</h2></a>
<p><a id="k-buckets-1" href="#k-buckets-1" class="paragraph">1</a>K-buckets is a data structure for efficiently storing a set of nodes close to a certain key called the base key. The base key is constant throughout the lifetime of a k-buckets instance.</p>
<p><a id="k-buckets-2" href="#k-buckets-2" class="paragraph">2</a>A k-buckets is a map from small integers <code>0 &lt;= n &lt; 256</code> to a set of up to <code>k</code> Node Infos. The set is called a bucket. <code>k</code> is called the bucket size. The default bucket size is 8.</p>
<p><a id="k-buckets-3" href="#k-buckets-3" class="paragraph">3</a>The number <code>n</code> is the bucket index. It is positive integer with the range <code>[0, 255]</code>, i.e. the range of an 8 bit unsigned integer.</p>
<p><a id="k-buckets-4" href="#k-buckets-4" class="paragraph">4</a>A bucket entry is an element of the bucket. The bucket is an ordered set, and the entries are sorted by <a href="#distance">distance</a> from the base key. Thus, the first (smallest) element of the set is the closest one to the base key in that set, the last (greatest) element is the furthest away.</p>
<a href="#bucket-index"><h3 id="bucket-index">
<span class="header-section-number">5.2.1</span> Bucket Index</h3></a>
<p><a id="bucket-index-1" href="#bucket-index-1" class="paragraph">1</a>The bucket index can be computed using the following function: <code>bucketIndex(baseKey, nodeKey) = 255 - log_2(distance(baseKey, nodeKey))</code>. This function is not defined when <code>baseKey == nodeKey</code>, meaning k-buckets will never contain a Node Info about the local node.</p>
<p><a id="bucket-index-2" href="#bucket-index-2" class="paragraph">2</a>Thus, each k-bucket contains only Node Infos for whose keys the following holds: if node with key <code>nodeKey</code> is in k-bucket with index <code>n</code>, then <code>bucketIndex(baseKey, nodeKey) == n</code>.</p>
<p><a id="bucket-index-3" href="#bucket-index-3" class="paragraph">3</a>The bucket index can be efficiently computed by determining the first bit at which the two keys differ, starting from the most significant bit. So, if the local DHT key starts with e.g. <code>0x80</code> and the bucketed node key starts with <code>0x40</code>, then the bucket index for that node is 0. If the second bit differs, the bucket index is 1. If the keys are almost exactly equal and only the last bit differs, the bucket index is 255.</p>
<a href="#manipulating-k-buckets"><h3 id="manipulating-k-buckets">
<span class="header-section-number">5.2.2</span> Manipulating k-buckets</h3></a>
<p><a id="manipulating-k-buckets-1" href="#manipulating-k-buckets-1" class="paragraph">1</a>Any update or lookup operation on a k-buckets instance that involves a single node requires us to first compute the bucket index for that node. An update involving a Node Info with <code>nodeKey == baseKey</code> has no effect. If the update results in an empty bucket, that bucket is removed from the map.</p>
<p><a id="manipulating-k-buckets-2" href="#manipulating-k-buckets-2" class="paragraph">2</a>A bucket is <em>full</em> when the bucket contains the maximum number of entries configured by the bucket size.</p>
<p><a id="manipulating-k-buckets-3" href="#manipulating-k-buckets-3" class="paragraph">3</a>A node is <em>viable</em> for entry if the bucket is not <em>full</em> or the node’s public key has a lower distance from the base key than the current entry with the greatest distance.</p>
<p><a id="manipulating-k-buckets-4" href="#manipulating-k-buckets-4" class="paragraph">4</a>If a node is <em>viable</em> and the bucket is <em>full</em>, the entry with the greatest distance from the base key is removed to keep the bucket size below the maximum configured bucket size.</p>
<p><a id="manipulating-k-buckets-5" href="#manipulating-k-buckets-5" class="paragraph">5</a>Adding a node whose key already exists will result in an update of the Node Info in the bucket. Removing a node for which no Node Info exists in the k-buckets has no effect. Thus, removing a node twice is permitted and has the same effect as removing it once.</p>
<p><a id="manipulating-k-buckets-6" href="#manipulating-k-buckets-6" class="paragraph">6</a>Iteration order of a k-buckets instance is in order of distance from the base key. I.e. the first node seen in iteration is the closest, and the last node is the furthest away in terms of the distance metric.</p>
<a href="#dht-node-state"><h2 id="dht-node-state">
<span class="header-section-number">5.3</span> DHT node state</h2></a>
<p><a id="dht-node-state-1" href="#dht-node-state-1" class="paragraph">1</a>Every DHT node contains the following state:</p>
<ul>
<li>DHT Key Pair: The Key Pair used to communicate with other DHT nodes. It is immutable throughout the lifetime of the DHT node.</li>
<li>DHT Close List: A set of Node Infos of nodes that are close to the DHT Public Key (public part of the DHT Key Pair). The Close List is represented as a <a href="#k-buckets">k-buckets</a> data structure, with the DHT Public Key as the Base Key.</li>
<li>DHT Search List: A list of Public Keys of nodes that the DHT node is searching for, associated with a DHT Search Entry.</li>
</ul>
<p><a id="dht-node-state-2" href="#dht-node-state-2" class="paragraph">2</a>A DHT node state is initialised using a Key Pair, which is stored in the state as DHT Key Pair and as base key for the Close List. Both the Close and Search Lists are initialised to be empty.</p>
<a href="#dht-search-entry"><h3 id="dht-search-entry">
<span class="header-section-number">5.3.1</span> DHT Search Entry</h3></a>
<p><a id="dht-search-entry-1" href="#dht-search-entry-1" class="paragraph">1</a>A DHT Search Entry contains a k-buckets instance, which serves the same purpose as the Close List, but the base key is the searched node’s Public Key. Once the searched node is found, it is also stored in the Search Entry. Recall that k-buckets never contain a Node Info for the base key, so it must be stored outside the k-buckets instance.</p>
<p><a id="dht-search-entry-2" href="#dht-search-entry-2" class="paragraph">2</a>A Search Entry is initialised with the searched-for Public Key. The contained k-buckets instance is initialised to be empty.</p>
<a href="#manipulating-the-dht-node-state"><h3 id="manipulating-the-dht-node-state">
<span class="header-section-number">5.3.2</span> Manipulating the DHT node state</h3></a>
<p><a id="manipulating-the-dht-node-state-1" href="#manipulating-the-dht-node-state-1" class="paragraph">1</a>Adding a search node to the DHT node state creates an empty entry in the Search Nodes list. If a search entry for the public key already existed, the “add” operation has no effect.</p>
<p><a id="manipulating-the-dht-node-state-2" href="#manipulating-the-dht-node-state-2" class="paragraph">2</a>Removing a search node removes its search entry and all associated data structures from memory.</p>
<p><a id="manipulating-the-dht-node-state-3" href="#manipulating-the-dht-node-state-3" class="paragraph">3</a>The iteration order over the DHT state is to first process the Close List k-buckets, then the Search List entry k-buckets. Each list itself follows the iteration order in the k-buckets specification.</p>
<p><a id="manipulating-the-dht-node-state-4" href="#manipulating-the-dht-node-state-4" class="paragraph">4</a>The size of the DHT state is defined to be the number of node infos it contains. Node infos contained multiple times, e.g. as part of the close list and as part of various search entries, are counted as many times as they appear.</p>
<p><a id="manipulating-the-dht-node-state-5" href="#manipulating-the-dht-node-state-5" class="paragraph">5</a>Search nodes do not directly count towards the state size. The state size is relevant to later pruning algorithms that decide when to remove a node info and when to request a ping from stale nodes. Search nodes, once added, are never automatically pruned.</p>
<p><a id="manipulating-the-dht-node-state-6" href="#manipulating-the-dht-node-state-6" class="paragraph">6</a>Adding and removing a node (Node Info) to the state is done by adding or removing the node to each k-bucket in the state, i.e. the close list and all the k-buckets in the search entries.</p>
<p><a id="manipulating-the-dht-node-state-7" href="#manipulating-the-dht-node-state-7" class="paragraph">7</a>When adding a node to the state, the search entry for the node’s public key, if it exists, is updated to contain the new Node Info. All k-buckets that already contain the node will also be updated. See the k-buckets specification for the update algorithm.</p>
<p><a id="manipulating-the-dht-node-state-8" href="#manipulating-the-dht-node-state-8" class="paragraph">8</a>Removing a node from the state unsets the Node Info in the search entry, if such exists. The search entry itself is not removed. All k-buckets that contained the node will no longer contain it after removing the node from the state. The only reference to the node’s public key will be the search entry, if it exists.</p>
<a href="#self-organisation"><h2 id="self-organisation">
<span class="header-section-number">5.4</span> Self-organisation</h2></a>
<p><a id="self-organisation-1" href="#self-organisation-1" class="paragraph">1</a>Self-organising in the DHT occurs through each DHT peer connecting to an arbitrary number of peers closest to their own DHT public key and some that are further away.</p>
<p><a id="self-organisation-2" href="#self-organisation-2" class="paragraph">2</a>If each peer in the network knows the peers with the DHT public key closest to its DHT public key, then to find a specific peer with public key X a peer just needs to recursively ask peers in the DHT for known peers that have the DHT public keys closest to X. Eventually the peer will find the peers in the DHT that are the closest to that peer and, if that peer is online, they will find them.</p>
<a href="#dht-packet"><h2 id="dht-packet">
<span class="header-section-number">5.5</span> DHT Packet</h2></a>
<p><a id="dht-packet-1" href="#dht-packet-1" class="paragraph">1</a>The DHT Packet contains the sender’s DHT Public Key, an encryption Nonce, and an encrypted payload. The payload is encrypted with the the DHT secret key of the sender, the DHT public key of the receiver, and the nonce that is sent along with the packet. DHT Packets are sent inside Protocol Packets with a varying Packet Kind.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Packet Kind</td>
<td style="text-align: left;">The packet kind identifier</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Sender DHT Public Key</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
<td style="text-align: left;">Random nonce</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>[16,]</code></td>
<td style="text-align: left;">Bytes</td>
<td style="text-align: left;">Encrypted payload</td>
</tr>
</tbody>
</table>
<p><a id="dht-packet-2" href="#dht-packet-2" class="paragraph">2</a>The encrypted payload is at least 16 bytes long, because the encryption includes a <a href="https://en.wikipedia.org/wiki/Message_authentication_code">MAC</a> of 16 bytes. A 16 byte payload would thus be the empty message. The DHT protocol never actually sends empty messages, so in reality the minimum size is 27 bytes for the <a href="#ping-service">Ping Packet</a>.</p>
<a href="#rpc-services"><h2 id="rpc-services">
<span class="header-section-number">5.6</span> RPC Services</h2></a>
<p><a id="rpc-services-1" href="#rpc-services-1" class="paragraph">1</a>A DHT RPC Service consists of a Request packet and a Response packet. A DHT RPC Packet contains a payload and a Request ID. This ID is a 64 bit unsigned integer that helps identify the response for a given request. The Request ID in the response packet must be equal to the Request ID in the request it is responding to.</p>
<p><a id="rpc-services-2" href="#rpc-services-2" class="paragraph">2</a>DHT RPC Packets are encrypted and transported within DHT Packets.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Packet Kind</td>
<td style="text-align: left;">The packet kind identifier</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Sender DHT Public Key</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
<td style="text-align: left;">Random nonce</td>
</tr>
<tr><td colspan="3" style="text-align: center">Start encrypted payload</td></tr>
<tr class="packet-row">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;">Bytes</td>
<td style="text-align: left;">Payload</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;">Request ID</td>
</tr>
<tr><td colspan="3" style="text-align: center">End encrypted payload</td></tr>
</tbody>
</table>
<p><a id="rpc-services-3" href="#rpc-services-3" class="paragraph">3</a>The minimum payload size is 0, but in reality the smallest sensible payload size is 1. Since the same symmetric key is used in both communication directions, an encrypted Request would be a valid encrypted Response if they contained the same plaintext.</p>
<p><a id="rpc-services-4" href="#rpc-services-4" class="paragraph">4</a>Parts of the protocol using RPC packets must take care to make Request payloads not be valid Response payloads. For instance, <a href="#ping-service">Ping Packets</a> carry a boolean flag that indicate whether the payload corresponds to a Request or a Response.</p>
<p><a id="rpc-services-5" href="#rpc-services-5" class="paragraph">5</a>The Request ID provides some resistance against replay attacks. If there were no Request ID, it would be easy for an attacker to replay old responses and thus provide nodes with out-of-date information. The exact value of the Request ID will be specified later in the DHT section.</p>
<a href="#ping-service"><h3 id="ping-service">
<span class="header-section-number">5.6.1</span> Ping Service</h3></a>
<p><a id="ping-service-1" href="#ping-service-1" class="paragraph">1</a>The Ping Service is used to periodically check if another node is still alive.</p>
<p><a id="ping-service-2" href="#ping-service-2" class="paragraph">2</a>A Ping Packet payload consists of just a boolean value saying whether it is a request or a response.</p>
<p><a id="ping-service-3" href="#ping-service-3" class="paragraph">3</a>The one byte boolean inside the encrypted payload is added to prevent peers from creating a valid Ping Response from a Ping Request without decrypting the packet and encrypting a new one. Since symmetric encryption is used, the encrypted Ping Response would be byte-wise equal to the Ping Request without the discriminator byte.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Packet Kind</td>
<td style="text-align: left;">The packet kind identifier</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Sender DHT Public Key</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
<td style="text-align: left;">Random nonce</td>
</tr>
<tr><td colspan="3" style="text-align: center">Start encrypted payload</td></tr>
<tr class="packet-row">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Bool</td>
<td style="text-align: left;">Response flag: 0x00 for Request, 0x01 for Response</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;">Request ID</td>
</tr>
<tr><td colspan="3" style="text-align: center">End encrypted payload</td></tr>
</tbody>
</table>
<a href="#ping-request-0x00"><h4 id="ping-request-0x00">
<span class="header-section-number">5.6.1.1</span> Ping Request (0x00)</h4></a>
<p><a id="ping-request-0x00-1" href="#ping-request-0x00-1" class="paragraph">1</a>A Ping Request is a Ping Packet with the response flag set to False. When a Ping Request is received and successfully decrypted, a Ping Response packet is created and sent back to the requestor.</p>
<a href="#ping-response-0x01"><h4 id="ping-response-0x01">
<span class="header-section-number">5.6.1.2</span> Ping Response (0x01)</h4></a>
<p><a id="ping-response-0x01-1" href="#ping-response-0x01-1" class="paragraph">1</a>A Ping Response is a Ping Packet with the response flag set to True.</p>
<a href="#nodes-service"><h3 id="nodes-service">
<span class="header-section-number">5.6.2</span> Nodes Service</h3></a>
<p><a id="nodes-service-1" href="#nodes-service-1" class="paragraph">1</a>The Nodes Service is used to query another DHT node for up to 4 nodes they know that are the closest to a requested node.</p>
<a href="#nodes-request-0x02"><h4 id="nodes-request-0x02">
<span class="header-section-number">5.6.2.1</span> Nodes Request (0x02)</h4></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Packet Kind</td>
<td style="text-align: left;">The packet kind identifier: 0x02</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Sender DHT Public Key</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
<td style="text-align: left;">Random nonce</td>
</tr>
<tr><td colspan="3" style="text-align: center">Start encrypted payload</td></tr>
<tr class="packet-row">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;"> Requested DHT Public Key</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;">Request ID</td>
</tr>
<tr><td colspan="3" style="text-align: center">End encrypted payload</td></tr>
</tbody>
</table>
<p><a id="nodes-request-0x02-1" href="#nodes-request-0x02-1" class="paragraph">1</a>The DHT Public Key sent in the request is the one the sender is searching for.</p>
<a href="#nodes-response-0x04"><h4 id="nodes-response-0x04">
<span class="header-section-number">5.6.2.2</span> Nodes Response (0x04)</h4></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Packet Kind</td>
<td style="text-align: left;">The packet kind identifier: 0x04</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Sender DHT Public Key</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
<td style="text-align: left;">Random nonce</td>
</tr>
<tr><td colspan="3" style="text-align: center">Start encrypted payload</td></tr>
<tr class="packet-row">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;"> Number of nodes in the response (maximum 4)</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>[39, 204]</code></td>
<td style="text-align: left;">Node Infos</td>
<td style="text-align: left;">Nodes in Packed Node Format</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;">Request ID</td>
</tr>
<tr><td colspan="3" style="text-align: center">End encrypted payload</td></tr>
</tbody>
</table>
<p><a id="nodes-response-0x04-1" href="#nodes-response-0x04-1" class="paragraph">1</a>An IPv4 node is 39 bytes, an IPv6 node is 51 bytes, so the maximum size is <code>51 * 4 = 204</code> bytes.</p>
<p><a id="nodes-response-0x04-2" href="#nodes-response-0x04-2" class="paragraph">2</a>Nodes responses should contain the 4 closest nodes that the sender of the response has in their list of known nodes.</p>
<a href="#packed-node-format"><h3 id="packed-node-format">
<span class="header-section-number">5.6.3</span> Packed node format</h3></a>
<p><a id="packed-node-format-1" href="#packed-node-format-1" class="paragraph">1</a>The DHT Send nodes uses the Packed Node Format.</p>
<p><a id="packed-node-format-2" href="#packed-node-format-2" class="paragraph">2</a>Only the UDP Protocol (IP Type <code>2</code> and <code>10</code>) are used in the DHT module when sending nodes with the packed node format. This is because the TCP Protocol is used to send TCP relay information and the DHT is UDP only.</p>
<p><a id="packed-node-format-3" href="#packed-node-format-3" class="paragraph">3</a>This is done to increase the speed at which peers are found. Toxcore also stores the 8 nodes (Must be the same or smaller than the nodes toxcore stores for each index in its close list to make sure all the closest peers found will know the node being searched) closest to each of the public keys in its DHT friends list (or list of DHT public keys that it actively tries to find and connect to). Toxcore pings every node in the lists every 60 seconds to see if they are alive. It does not store itself in either list and does not send any requests to itself. Nodes can be in more than one list for example if the DHT public key of the peer is very close to the DHT public key of a friend being searched. It also sends get node requests to a random node (random makes it unpredictable, predictability or knowing which node a node will ping next could make some attacks that disrupt the network more easy as it adds a possible attack vector) in each of these lists of nodes every 20 seconds, with the search public key being its public key for the closest node and the public key being searched for being the ones in the DHT friends list. Nodes are removed after 122 seconds of no response. Nodes are added to the lists after a valid ping response or send node packet is received from them. If the node is already present in the list it is updated if the IP address changed. A node can only be added to a list if the list is not full or if the nodes DHT public key is closer than the DHT public key of at least one of the nodes in the list to the public key being searched with that list. When a node is added to a full list, it will replace the furthest node.</p>
<p><a id="packed-node-format-4" href="#packed-node-format-4" class="paragraph">4</a>If the 32 nodes number where increased, it would increase the amount of packets needed to check if each of them are still alive which would increase the bandwidth usage but reliability would go up. If the number of nodes were decreased, reliability would go down along with bandwidth usage. The reason for this relationship between reliability and number of nodes is that if we assume that not every node has its UDP ports open or is behind a cone NAT it means that each of these nodes must be able to store a certain number of nodes behind restrictive NATs in order for others to be able to find those nodes behind restrictive NATs. For example if 7/8 nodes were behind restrictive NATs, using 8 nodes would not be enough because the chances of some of these nodes being impossible to find in the network would be too high.</p>
<p><a id="packed-node-format-5" href="#packed-node-format-5" class="paragraph">5</a>If the ping timeouts and delays between pings were higher it would decrease the bandwidth usage but increase the amount of disconnected nodes that are still being stored in the lists. Decreasing these delays would do the opposite.</p>
<p><a id="packed-node-format-6" href="#packed-node-format-6" class="paragraph">6</a>If the 8 nodes closest to each public key were increased to 16 it would increase the bandwidth usage, might increase hole punching efficiency on symmetric NATs (more ports to guess from, see Hole punching) and might increase the reliability. Lowering this number would have the opposite effect.</p>
<p><a id="packed-node-format-7" href="#packed-node-format-7" class="paragraph">7</a>When receiving a send node packet, toxcore will check if each of the received nodes could be added to any one of the lists. If the node can, toxcore will send a ping packet to it, if it cannot it will be ignored.</p>
<p><a id="packed-node-format-8" href="#packed-node-format-8" class="paragraph">8</a>When receiving a get node packet, toxcore will find the 4 nodes, in its nodes lists, closest to the public key in the packet and send them in the send node response.</p>
<p><a id="packed-node-format-9" href="#packed-node-format-9" class="paragraph">9</a>The timeouts and number of nodes in lists for toxcore where picked by feeling alone and are probably not the best values. This also applies to the behavior which is simple and should be improved in order to make the network resist better to sybil attacks.</p>
<a href="#dht-request-packets"><h2 id="dht-request-packets">
<span class="header-section-number">5.7</span> DHT Request packets</h2></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x20)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">receiver’s DHT public key</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">sender’s DHT public key</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">nonce</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">encrypted message</td>
</tr>
</tbody>
</table>
<p><a id="dht-request-packets-1" href="#dht-request-packets-1" class="paragraph">1</a>DHT Request packets are packets that can be sent across one DHT node to one that they know. They are used to send encrypted data to friends that we are not necessarily connected to directly in the DHT.</p>
<p><a id="dht-request-packets-2" href="#dht-request-packets-2" class="paragraph">2</a>A DHT node that receives a DHT request packet will check whether the node with the receivers public key is their DHT public key and, if it is, they will decrypt and handle the packet. If it is not they will check whether they know that DHT public key (if it’s in their list of close nodes). If it isn’t, they will drop the packet. If it is they will resend the exact packet to that DHT node.</p>
<p><a id="dht-request-packets-3" href="#dht-request-packets-3" class="paragraph">3</a>The encrypted message is encrypted using the receiver’s DHT Public key, the sender’s DHT private key and the nonce (randomly generated 24 bytes).</p>
<p><a id="dht-request-packets-4" href="#dht-request-packets-4" class="paragraph">4</a>DHT request packets are used for DHTPK packets (see onion) and NAT ping packets.</p>
<a href="#nat-ping-packets"><h3 id="nat-ping-packets">
<span class="header-section-number">5.7.1</span> NAT ping packets</h3></a>
<p><a id="nat-ping-packets-1" href="#nat-ping-packets-1" class="paragraph">1</a>Sits inside the DHT request packet.</p>
<p><a id="nat-ping-packets-2" href="#nat-ping-packets-2" class="paragraph">2</a>NAT ping packets are used to see if a friend we are not connected to directly is online and ready to do the hole punching.</p>
<a href="#nat-ping-request"><h4 id="nat-ping-request">
<span class="header-section-number">5.7.1.1</span> NAT ping request</h4></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0xfe)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x00)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">
<code>uint64_t</code> random number</td>
</tr>
</tbody>
</table>
<a href="#nat-ping-response"><h4 id="nat-ping-response">
<span class="header-section-number">5.7.1.2</span> NAT ping response</h4></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0xfe)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x01)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">
<code>uint64_t</code> random number (the same that was received in request)</td>
</tr>
</tbody>
</table>
<a href="#hole-punching"><h2 id="hole-punching">
<span class="header-section-number">5.8</span> Hole punching</h2></a>
<p><a id="hole-punching-1" href="#hole-punching-1" class="paragraph">1</a>For holepunching we assume that people using Tox are on one of 3 types of NAT:</p>
<p><a id="hole-punching-2" href="#hole-punching-2" class="paragraph">2</a>Cone NATs: Assign one whole port to each UDP socket behind the NAT, any packet from any IP/port sent to that assigned port from the internet will be forwarded to the socket behind it.</p>
<p><a id="hole-punching-3" href="#hole-punching-3" class="paragraph">3</a>Restricted Cone NATs: Assign one whole port to each UDP socket behind the NAT. However, it will only forward packets from IPs that the UDP socket has sent a packet to.</p>
<p><a id="hole-punching-4" href="#hole-punching-4" class="paragraph">4</a>Symmetric NATs: The worst kind of NAT, they assign a new port for each IP/port a packet is sent to. They treat each new peer you send a UDP packet to as a <code>'connection'</code> and will only forward packets from the IP/port of that <code>'connection'</code>.</p>
<p><a id="hole-punching-5" href="#hole-punching-5" class="paragraph">5</a>Holepunching on normal cone NATs is achieved simply through the way in which the DHT functions.</p>
<p><a id="hole-punching-6" href="#hole-punching-6" class="paragraph">6</a>If more than half of the 8 peers closest to the friend in the DHT return an IP/port for the friend and we send a ping request to each of the returned IP/ports but get no response. If we have sent 4 ping requests to 4 IP/ports that supposedly belong to the friend and get no response, then this is enough for toxcore to start the hole punching. The numbers 8 and 4 are used in toxcore and where chosen based on feel alone and so may not be the best numbers.</p>
<p><a id="hole-punching-7" href="#hole-punching-7" class="paragraph">7</a>Before starting the hole punching, the peer will send a NAT ping packet to the friend via the peers that say they know the friend. If a NAT ping response with the same random number is received the hole punching will start.</p>
<p><a id="hole-punching-8" href="#hole-punching-8" class="paragraph">8</a>If a NAT ping request is received, we will first check if it is from a friend. If it is not from a friend it will be dropped. If it is from a friend, a response with the same 8 byte number as in the request will be sent back via the nodes that know the friend sending the request. If no nodes from the friend are known, the packet will be dropped.</p>
<p><a id="hole-punching-9" href="#hole-punching-9" class="paragraph">9</a>Receiving a NAT ping response therefore means that the friend is both online and actively searching for us, as that is the only way they would know nodes that know us. This is important because hole punching will work only if the friend is actively trying to connect to us.</p>
<p><a id="hole-punching-10" href="#hole-punching-10" class="paragraph">10</a>NAT ping requests are sent every 3 seconds in toxcore, if no response is received for 6 seconds, the hole punching will stop. Sending them in longer intervals might increase the possibility of the other node going offline and ping packets sent in the hole punching being sent to a dead peer but decrease bandwidth usage. Decreasing the intervals will have the opposite effect.</p>
<p><a id="hole-punching-11" href="#hole-punching-11" class="paragraph">11</a>There are 2 cases that toxcore handles for the hole punching. The first case is if each 4+ peers returned the same IP and port. The second is if the 4+ peers returned same IPs but different ports.</p>
<p><a id="hole-punching-12" href="#hole-punching-12" class="paragraph">12</a>A third case that may occur is the peers returning different IPs and ports. This can only happen if the friend is behind a very restrictive NAT that cannot be hole punched or if the peer recently connected to another internet connection and some peers still have the old one stored. Since there is nothing we can do for the first option it is recommended to just use the most common IP returned by the peers and to ignore the other IP/ports.</p>
<p><a id="hole-punching-13" href="#hole-punching-13" class="paragraph">13</a>In the case where the peers return the same IP and port it means that the other friend is on a restricted cone NAT. These kind of NATs can be hole punched by getting the friend to send a packet to our public IP/port. This means that hole punching can be achieved easily and that we should just continue sending DHT ping packets regularly to that IP/port until we get a ping response. This will work because the friend is searching for us in the DHT and will find us and will send us a packet to our public IP/port (or try to with the hole punching), thereby establishing a connection.</p>
<p><a id="hole-punching-14" href="#hole-punching-14" class="paragraph">14</a>For the case where peers do not return the same ports, this means that the other peer is on a symmetric NAT. Some symmetric NATs open ports in sequences so the ports returned by the other peers might be something like: 1345, 1347, 1389, 1395. The method to hole punch these NATs is to try to guess which ports are more likely to be used by the other peer when they try sending us ping requests and send some ping requests to these ports. Toxcore just tries all the ports beside each returned port (ex: for the 4 ports previously it would try: 1345, 1347, 1389, 1395, 1346, 1348, 1390, 1396, 1344, 1346…) getting gradually further and further away and, although this works, the method could be improved. When using this method toxcore will try up to 48 ports every 3 seconds until both connect. After 5 tries toxcore doubles this and starts trying ports from 1024 (48 each time) along with the previous port guessing. This is because I have noticed that this seemed to fix it for some symmetric NATs, most likely because a lot of them restart their count at 1024.</p>
<p><a id="hole-punching-15" href="#hole-punching-15" class="paragraph">15</a>Increasing the amount of ports tried per second would make the hole punching go faster but might DoS NATs due to the large number of packets being sent to different IPs in a short amount of time. Decreasing it would make the hole punching slower.</p>
<p><a id="hole-punching-16" href="#hole-punching-16" class="paragraph">16</a>This works in cases where both peers have different NATs. For example, if A and B are trying to connect to each other: A has a symmetric NAT and B a restricted cone NAT. A will detect that B has a restricted cone NAT and keep sending ping packets to his one IP/port. B will detect that A has a symmetric NAT and will send packets to it to try guessing his ports. If B manages to guess the port A is sending packets from they will connect together.</p>
<a href="#lan-discovery"><h1 id="lan-discovery">
<span class="header-section-number">6</span> LAN discovery</h1></a>
<p><a id="lan-discovery-1" href="#lan-discovery-1" class="paragraph">1</a>LAN discovery is a way to discover Tox peers that are on a local network. If two Tox friends are on a local network, the most efficient way for them to communicate together is to use the local network. If a Tox client is opened on a local network in which another Tox client exists then good behavior would be to bootstrap to the network using the Tox client on the local network. This is what LAN discovery aims to accomplish.</p>
<p><a id="lan-discovery-2" href="#lan-discovery-2" class="paragraph">2</a>LAN discovery works by sending a UDP packet through the toxcore UDP socket to the interface broadcast address on IPv4, the global broadcast address (255.255.255.255) and the multicast address on IPv6 (FF02::1) on the default Tox UDP port (33445).</p>
<p><a id="lan-discovery-3" href="#lan-discovery-3" class="paragraph">3</a>The LAN Discovery packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (33)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">DHT public key</td>
</tr>
</tbody>
</table>
<p><a id="lan-discovery-4" href="#lan-discovery-4" class="paragraph">4</a>LAN Discovery packets contain the DHT public key of the sender. When a LAN Discovery packet is received, a DHT get nodes packet will be sent to the sender of the packet. This means that the DHT instance will bootstrap itself to every peer from which it receives one of these packet. Through this mechanism, Tox clients will bootstrap themselves automatically from other Tox clients running on the local network.</p>
<p><a id="lan-discovery-5" href="#lan-discovery-5" class="paragraph">5</a>Toxcore sends these packets every 10 seconds to keep delays low. The packets could be sent up to every 60 seconds but this would make peer finding over the network 6 times slower.</p>
<p><a id="lan-discovery-6" href="#lan-discovery-6" class="paragraph">6</a>LAN discovery enables two friends on a local network to find each other as the DHT prioritizes LAN addresses over non LAN addresses for DHT peers. Sending a get node request/bootstrapping from a peer successfully should also add them to the list of DHT peers if we are searching for them. The peer must not be immediately added if a LAN discovery packet with a DHT public key that we are searching for is received as there is no cryptographic proof that this packet is legitimate and not maliciously crafted. This means that a DHT get node or ping packet must be sent, and a valid response must be received, before we can say that this peer has been found.</p>
<p><a id="lan-discovery-7" href="#lan-discovery-7" class="paragraph">7</a>LAN discovery is how Tox handles and makes everything work well on LAN.</p>
<a href="#messenger"><h1 id="messenger">
<span class="header-section-number">7</span> Messenger</h1></a>
<p><a id="messenger-1" href="#messenger-1" class="paragraph">1</a>Messenger is the module at the top of all the other modules. It sits on top of <code>friend_connection</code> in the hierarchy of toxcore.</p>
<p><a id="messenger-2" href="#messenger-2" class="paragraph">2</a>Messenger takes care of sending and receiving messages using the connection provided by <code>friend_connection</code>. The module provides a way for friends to connect and makes it usable as an instant messenger. For example, Messenger lets users set a nickname and status message which it then transmits to friends when they are online. It also allows users to send messages to friends and builds an instant messenging system on top of the lower level <code>friend_connection</code> module.</p>
<p><a id="messenger-3" href="#messenger-3" class="paragraph">3</a>Messenger offers two methods to add a friend. The first way is to add a friend with only their long term public key, this is used when a friend needs to be added but for some reason a friend request should not be sent. The friend should only be added. This method is most commonly used to accept friend requests but could also be used in other ways. If two friends add each other using this function they will connect to each other. Adding a friend using this method just adds the friend to <code>friend_connection</code> and creates a new friend entry in Messenger for the friend.</p>
<p><a id="messenger-4" href="#messenger-4" class="paragraph">4</a>The Tox ID is used to identify peers so that they can be added as friends in Tox. In order to add a friend, a Tox user must have the friend’s Tox ID.The Tox ID contains the long term public key of the peer (32 bytes) followed by the 4 byte nospam (see: <code>friend_requests</code>) value and a 2 byte XOR checksum. The method of sending the Tox ID to others is up to the user and the client but the recommended way is to encode it in hexadecimal format and have the user manually send it to the friend using another program.</p>
<p><a id="messenger-5" href="#messenger-5" class="paragraph">5</a>Tox ID:</p>
<figure>
<img src="img/tox-id.png" alt="Tox ID"><figcaption>Tox ID</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">long term public key</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">nospam</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">checksum</td>
</tr>
</tbody>
</table>
<p><a id="messenger-6" href="#messenger-6" class="paragraph">6</a>The checksum is calculated by XORing the first two bytes of the ID with the next two bytes, then the next two bytes until all the 36 bytes have been XORed together. The result is then appended to the end to form the Tox ID.</p>
<p><a id="messenger-7" href="#messenger-7" class="paragraph">7</a>The user must make sure the Tox ID is not intercepted and replaced in transit by a different Tox ID, which would mean the friend would connect to a malicious person instead of the user, though taking reasonable precautions as this is outside the scope of Tox. Tox assumes that the user has ensured that they are using the correct Tox ID, belonging to the intended person, to add a friend.</p>
<p><a id="messenger-8" href="#messenger-8" class="paragraph">8</a>The second method to add a friend is by using their Tox ID and a message to be sent in a friend request. This way of adding friends will try to send a friend request, with the set message, to the peer whose Tox ID was added. The method is similar to the first one, except that a friend request is crafted and sent to the other peer.</p>
<p><a id="messenger-9" href="#messenger-9" class="paragraph">9</a>When a friend connection associated to a Messenger friend goes online, a ONLINE packet will be sent to them. Friends are only set as online if an ONLINE packet is received.</p>
<p><a id="messenger-10" href="#messenger-10" class="paragraph">10</a>As soon as a friend goes online, Messenger will stop sending friend requests to that friend, if it was sending them, as they are redundant for this friend.</p>
<p><a id="messenger-11" href="#messenger-11" class="paragraph">11</a>Friends will be set as offline if either the friend connection associated to them goes offline or if an OFFLINE packet is received from the friend.</p>
<p><a id="messenger-12" href="#messenger-12" class="paragraph">12</a>Messenger packets are sent to the friend using the online friend connection to the friend.</p>
<p><a id="messenger-13" href="#messenger-13" class="paragraph">13</a>Should Messenger need to check whether any of the non lossy packets in the following list were received by the friend, for example to implement receipts for text messages, <code>net_crypto</code> can be used. The <code>net_crypto</code> packet number, used to send the packets, should be noted and then <code>net_crypto</code> checked later to see if the bottom of the send array is after this packet number. If it is, then the friend has received them. Note that <code>net_crypto</code> packet numbers could overflow after a long time, so checks should happen within 2**32 <code>net_crypto</code> packets sent with the same friend connection.</p>
<p><a id="messenger-14" href="#messenger-14" class="paragraph">14</a>Message receipts for action messages and normal text messages are implemented by adding the <code>net_crypto</code> packet number of each message, along with the receipt number, to the top of a linked list that each friend has as they are sent. Every Messenger loop, the entries are read from the bottom and entries are removed and passed to the client until an entry that refers to a packet not yet received by the other is reached, when this happens it stops.</p>
<p><a id="messenger-15" href="#messenger-15" class="paragraph">15</a>List of Messenger packets:</p>
<a href="#online"><h2 id="online">
<span class="header-section-number">7.1</span> <code>ONLINE</code>
</h2></a>
<p><a id="online-1" href="#online-1" class="paragraph">1</a>length: 1 byte</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x18)</td>
</tr>
</tbody>
</table>
<p><a id="online-2" href="#online-2" class="paragraph">2</a>Sent to a friend when a connection is established to tell them to mark us as online in their friends list. This packet and the OFFLINE packet are necessary as <code>friend_connections</code> can be established with non-friends who are part of a groupchat. The two packets are used to differentiate between these peers, connected to the user through groupchats, and actual friends who ought to be marked as online in the friendlist.</p>
<p><a id="online-3" href="#online-3" class="paragraph">3</a>On receiving this packet, Messenger will show the peer as being online.</p>
<a href="#offline"><h2 id="offline">
<span class="header-section-number">7.2</span> <code>OFFLINE</code>
</h2></a>
<p><a id="offline-1" href="#offline-1" class="paragraph">1</a>length: 1 byte</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x19)</td>
</tr>
</tbody>
</table>
<p><a id="offline-2" href="#offline-2" class="paragraph">2</a>Sent to a friend when deleting the friend. Prevents a deleted friend from seeing us as online if we are connected to them because of a group chat.</p>
<p><a id="offline-3" href="#offline-3" class="paragraph">3</a>On receiving this packet, Messenger will show this peer as offline.</p>
<a href="#nickname"><h2 id="nickname">
<span class="header-section-number">7.3</span> <code>NICKNAME</code>
</h2></a>
<p><a id="nickname-1" href="#nickname-1" class="paragraph">1</a>length: 1 byte to 129 bytes.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x30)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[0, 128]</code></td>
<td style="text-align: left;">Nickname as a UTF8 byte string</td>
</tr>
</tbody>
</table>
<p><a id="nickname-2" href="#nickname-2" class="paragraph">2</a>Used to send the nickname of the peer to others. This packet should be sent every time to each friend every time they come online and each time the nickname is changed.</p>
<a href="#statusmessage"><h2 id="statusmessage">
<span class="header-section-number">7.4</span> <code>STATUSMESSAGE</code>
</h2></a>
<p><a id="statusmessage-1" href="#statusmessage-1" class="paragraph">1</a>length: 1 byte to 1008 bytes.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"> <code>uint8_t</code> (0x31)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[0, 1007]</code></td>
<td style="text-align: left;">Status message as a UTF8 byte string</td>
</tr>
</tbody>
</table>
<p><a id="statusmessage-2" href="#statusmessage-2" class="paragraph">2</a>Used to send the status message of the peer to others. This packet should be sent every time to each friend every time they come online and each time the status message is changed.</p>
<a href="#userstatus"><h2 id="userstatus">
<span class="header-section-number">7.5</span> <code>USERSTATUS</code>
</h2></a>
<p><a id="userstatus-1" href="#userstatus-1" class="paragraph">1</a>length: 2 bytes</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x32)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> status (0 = online, 1 = away, 2 = busy)</td>
</tr>
</tbody>
</table>
<p><a id="userstatus-2" href="#userstatus-2" class="paragraph">2</a>Used to send the user status of the peer to others. This packet should be sent every time to each friend every time they come online and each time the user status is changed.</p>
<a href="#typing"><h2 id="typing">
<span class="header-section-number">7.6</span> <code>TYPING</code>
</h2></a>
<p><a id="typing-1" href="#typing-1" class="paragraph">1</a>length: 2 bytes</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x33)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> typing status (0 = not typing, 1 = typing)</td>
</tr>
</tbody>
</table>
<p><a id="typing-2" href="#typing-2" class="paragraph">2</a>Used to tell a friend whether the user is currently typing or not.</p>
<a href="#message"><h2 id="message">
<span class="header-section-number">7.7</span> <code>MESSAGE</code>
</h2></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x40)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[0, 1372]</code></td>
<td style="text-align: left;">Message as a UTF8 byte string</td>
</tr>
</tbody>
</table>
<p><a id="message-1" href="#message-1" class="paragraph">1</a>Used to send a normal text message to the friend.</p>
<a href="#action"><h2 id="action">
<span class="header-section-number">7.8</span> <code>ACTION</code>
</h2></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x41)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[0, 1372]</code></td>
<td style="text-align: left;">Action message as a UTF8 byte string</td>
</tr>
</tbody>
</table>
<p><a id="action-1" href="#action-1" class="paragraph">1</a>Used to send an action message (like an IRC action) to the friend.</p>
<a href="#msi"><h2 id="msi">
<span class="header-section-number">7.9</span> <code>MSI</code>
</h2></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x45)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">data</td>
</tr>
</tbody>
</table>
<p><a id="msi-1" href="#msi-1" class="paragraph">1</a>Reserved for Tox AV usage.</p>
<a href="#file-transfer-related-packets"><h2 id="file-transfer-related-packets">
<span class="header-section-number">7.10</span> File Transfer Related Packets</h2></a>
<a href="#file_sendrequest"><h3 id="file_sendrequest">
<span class="header-section-number">7.10.1</span> <code>FILE_SENDREQUEST</code>
</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x50)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> file number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint32_t</code> file type</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">
<code>uint64_t</code> file size</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">file id (32 bytes)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[0, 255]</code></td>
<td style="text-align: left;">filename as a UTF8 byte string</td>
</tr>
</tbody>
</table>
<p><a id="file_sendrequest-1" href="#file_sendrequest-1" class="paragraph">1</a>Note that file type and file size are sent in big endian/network byte format.</p>
<a href="#file_control"><h3 id="file_control">
<span class="header-section-number">7.10.2</span> <code>FILE_CONTROL</code>
</h3></a>
<p><a id="file_control-1" href="#file_control-1" class="paragraph">1</a>length: 4 bytes if <code>control_type</code> isn’t seek. 8 bytes if <code>control_type</code> is seek.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x51)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> <code>send_receive</code>
</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> file number</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> <code>control_type</code>
</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">
<code>uint64_t</code> seek parameter</td>
</tr>
</tbody>
</table>
<p><a id="file_control-2" href="#file_control-2" class="paragraph">2</a><code>send_receive</code> is 0 if the control targets a file being sent (by the peer sending the file control), and 1 if it targets a file being received.</p>
<p><a id="file_control-3" href="#file_control-3" class="paragraph">3</a><code>control_type</code> can be one of: 0 = accept, 1 = pause, 2 = kill, 3 = seek.</p>
<p><a id="file_control-4" href="#file_control-4" class="paragraph">4</a>The seek parameter is only included when <code>control_type</code> is seek (3).</p>
<p><a id="file_control-5" href="#file_control-5" class="paragraph">5</a>Note that if it is included the seek parameter will be sent in big endian/network byte format.</p>
<a href="#file_data"><h3 id="file_data">
<span class="header-section-number">7.10.3</span> <code>FILE_DATA</code>
</h3></a>
<p><a id="file_data-1" href="#file_data-1" class="paragraph">1</a>length: 2 to 1373 bytes.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x52)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> file number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>[0, 1371]</code></td>
<td style="text-align: left;">file data piece</td>
</tr>
</tbody>
</table>
<p><a id="file_data-2" href="#file_data-2" class="paragraph">2</a>Files are transferred in Tox using File transfers.</p>
<p><a id="file_data-3" href="#file_data-3" class="paragraph">3</a>To initiate a file transfer, the friend creates and sends a <code>FILE_SENDREQUEST</code> packet to the friend it wants to initiate a file transfer to.</p>
<p><a id="file_data-4" href="#file_data-4" class="paragraph">4</a>The first part of the <code>FILE_SENDREQUEST</code> packet is the file number. The file number is the number used to identify this file transfer. As the file number is represented by a 1 byte number, the maximum amount of concurrent files Tox can send to a friend is 256. 256 file transfers per friend is enough that clients can use tricks like queueing files if there are more files needing to be sent.</p>
<p><a id="file_data-5" href="#file_data-5" class="paragraph">5</a>256 outgoing files per friend means that there is a maximum of 512 concurrent file transfers, between two users, if both incoming and outgoing file transfers are counted together.</p>
<p><a id="file_data-6" href="#file_data-6" class="paragraph">6</a>As file numbers are used to identify the file transfer, the Tox instance must make sure to use a file number that isn’t used for another outgoing file transfer to that same friend when creating a new outgoing file transfer. File numbers are chosen by the file sender and stay unchanged for the entire duration of the file transfer. The file number is used by both <code>FILE_CONTROL</code> and <code>FILE_DATA</code> packets to identify which file transfer these packets are for.</p>
<p><a id="file_data-7" href="#file_data-7" class="paragraph">7</a>The second part of the file transfer request is the file type. This is simply a number that identifies the type of file. for example, tox.h defines the file type 0 as being a normal file and type 1 as being an avatar meaning the Tox client should use that file as an avatar. The file type does not effect in any way how the file is transfered or the behavior of the file transfer. It is set by the Tox client that creates the file transfers and send to the friend untouched.</p>
<p><a id="file_data-8" href="#file_data-8" class="paragraph">8</a>The file size indicates the total size of the file that will be transfered. A file size of <code>UINT64_MAX</code> (maximum value in a <code>uint64_t</code>) means that the size of the file is undetermined or unknown. For example if someone wanted to use Tox file transfers to stream data they would set the file size to <code>UINT64_MAX</code>. A file size of 0 is valid and behaves exactly like a normal file transfer.</p>
<p><a id="file_data-9" href="#file_data-9" class="paragraph">9</a>The file id is 32 bytes that can be used to uniquely identify the file transfer. For example, avatar transfers use it as the hash of the avatar so that the receiver can check if they already have the avatar for a friend which saves bandwidth. It is also used to identify broken file transfers across toxcore restarts (for more info see the file transfer section of tox.h). The file transfer implementation does not care about what the file id is, as it is only used by things above it.</p>
<p><a id="file_data-10" href="#file_data-10" class="paragraph">10</a>The last part of the file transfer is the optional file name which is used to tell the receiver the name of the file.</p>
<p><a id="file_data-11" href="#file_data-11" class="paragraph">11</a>When a <code>FILE_SENDREQUEST</code> packet is received, the implementation validates and sends the info to the Tox client which decides whether they should accept the file transfer or not.</p>
<p><a id="file_data-12" href="#file_data-12" class="paragraph">12</a>To refuse or cancel a file transfer, they will send a <code>FILE_CONTROL</code> packet with <code>control_type</code> 2 (kill).</p>
<p><a id="file_data-13" href="#file_data-13" class="paragraph">13</a><code>FILE_CONTROL</code> packets are used to control the file transfer. <code>FILE_CONTROL</code> packets are used to accept/unpause, pause, kill/cancel and seek file transfers. The <code>control_type</code> parameter denotes what the file control packet does.</p>
<p><a id="file_data-14" href="#file_data-14" class="paragraph">14</a>The <code>send_receive</code> and file number are used to identify a specific file transfer. Since file numbers for outgoing and incoming files are not related to each other, the <code>send_receive</code> parameter is used to identify if the file number belongs to files being sent or files being received. If <code>send_receive</code> is 0, the file number corresponds to a file being sent by the user sending the file control packet. If <code>send_receive</code> is 1, it corresponds to a file being received by the user sending the file control packet.</p>
<p><a id="file_data-15" href="#file_data-15" class="paragraph">15</a><code>control_type</code> indicates the purpose of the <code>FILE_CONTROL</code> packet. <code>control_type</code> of 0 means that the <code>FILE_CONTROL</code> packet is used to tell the friend that the file transfer is accepted or that we are unpausing a previously paused (by us) file transfer. <code>control_type</code> of 1 is used to tell the other to pause the file transfer.</p>
<p><a id="file_data-16" href="#file_data-16" class="paragraph">16</a>If one party pauses a file transfer, that party must be the one to unpause it. Should both sides pause a file transfer, both sides must unpause it before the file can be resumed. For example, if the sender pauses the file transfer, the receiver must not be able to unpause it. To unpause a file transfer, <code>control_type</code> 0 is used. Files can only be paused when they are in progress and have been accepted.</p>
<p><a id="file_data-17" href="#file_data-17" class="paragraph">17</a><code>control_type</code> 2 is used to kill, cancel or refuse a file transfer. When a <code>FILE_CONTROL</code> is received, the targeted file transfer is considered dead, will immediately be wiped and its file number can be reused. The peer sending the <code>FILE_CONTROL</code> must also wipe the targeted file transfer from their side. This control type can be used by both sides of the transfer at any time.</p>
<p><a id="file_data-18" href="#file_data-18" class="paragraph">18</a><code>control_type</code> 3, the seek control type is used to tell the sender of the file to start sending from a different index in the file than 0. It can only be used right after receiving a <code>FILE_SENDREQUEST</code> packet and before accepting the file by sending a <code>FILE_CONTROL</code> with <code>control_type</code> 0. When this <code>control_type</code> is used, an extra 8 byte number in big endian format is appended to the <code>FILE_CONTROL</code> that is not present with other control types. This number indicates the index in bytes from the beginning of the file at which the file sender should start sending the file. The goal of this control type is to ensure that files can be resumed across core restarts. Tox clients can know if they have received a part of a file by using the file id and then using this packet to tell the other side to start sending from the last received byte. If the seek position is bigger or equal to the size of the file, the seek packet is invalid and the one receiving it will discard it.</p>
<p><a id="file_data-19" href="#file_data-19" class="paragraph">19</a>To accept a file Tox will therefore send a seek packet, if it is needed, and then send a <code>FILE_CONTROL</code> packet with <code>control_type</code> 0 (accept) to tell the file sender that the file was accepted.</p>
<p><a id="file_data-20" href="#file_data-20" class="paragraph">20</a>Once the file transfer is accepted, the file sender will start sending file data in sequential chunks from the beginning of the file (or the position from the <code>FILE_CONTROL</code> seek packet if one was received).</p>
<p><a id="file_data-21" href="#file_data-21" class="paragraph">21</a>File data is sent using <code>FILE_DATA</code> packets. The file number corresponds to the file transfer that the file chunks belong to. The receiver assumes that the file transfer is over as soon as a chunk with the file data size not equal to the maximum size (1371 bytes) is received. This is how the sender tells the receiver that the file transfer is complete in file transfers where the size of the file is unknown (set to <code>UINT64_MAX</code>). The receiver also assumes that if the amount of received data equals to the file size received in the <code>FILE_SENDREQUEST</code>, the file sending is finished and has been successfully received. Immediately after this occurs, the receiver frees up the file number so that a new incoming file transfer can use that file number. The implementation should discard any extra data received which is larger than the file size received at the beginning.</p>
<p><a id="file_data-22" href="#file_data-22" class="paragraph">22</a>In 0 filesize file transfers, the sender will send one <code>FILE_DATA</code> packet with a file data size of 0.</p>
<p><a id="file_data-23" href="#file_data-23" class="paragraph">23</a>The sender will know if the receiver has received the file successfully by checking if the friend has received the last <code>FILE_DATA</code> packet sent (containing the last chunk of the file). <code>Net_crypto</code> can be used to check whether packets sent through it have been received by storing the packet number of the sent packet and verifying later in <code>net_crypto</code> to see whether it was received or not. As soon as <code>net_crypto</code> says the other received the packet, the file transfer is considered successful, wiped and the file number can be reused to send new files.</p>
<p><a id="file_data-24" href="#file_data-24" class="paragraph">24</a><code>FILE_DATA</code> packets should be sent as fast as the <code>net_crypto</code> connection can handle it respecting its congestion control.</p>
<p><a id="file_data-25" href="#file_data-25" class="paragraph">25</a>If the friend goes offline, all file transfers are cleared in toxcore. This makes it simpler for toxcore as it does not have to deal with resuming file transfers. It also makes it simpler for clients as the method for resuming file transfers remains the same, even if the client is restarted or toxcore loses the connection to the friend because of a bad internet connection.</p>
<a href="#group-chat-related-packets"><h2 id="group-chat-related-packets">
<span class="header-section-number">7.11</span> Group Chat Related Packets</h2></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Packet ID</th>
<th style="text-align: left;">Packet Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0x60</td>
<td style="text-align: left;"><code>INVITE_GROUPCHAT</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">0x61</td>
<td style="text-align: left;"><code>ONLINE_PACKET</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">0x62</td>
<td style="text-align: left;"><code>DIRECT_GROUPCHAT</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">0x63</td>
<td style="text-align: left;"><code>MESSAGE_GROUPCHAT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">0xC7</td>
<td style="text-align: left;"><code>LOSSY_GROUPCHAT</code></td>
</tr>
</tbody>
</table>
<p><a id="group-chat-related-packets-1" href="#group-chat-related-packets-1" class="paragraph">1</a>Messenger also takes care of saving the friends list and other friend information so that it’s possible to close and start toxcore while keeping all your friends, your long term key and the information necessary to reconnect to the network.</p>
<p><a id="group-chat-related-packets-2" href="#group-chat-related-packets-2" class="paragraph">2</a>Important information messenger stores includes: the long term private key, our current nospam value, our friends’ public keys and any friend requests the user is currently sending. The network DHT nodes, TCP relays and some onion nodes are stored to aid reconnection.</p>
<p><a id="group-chat-related-packets-3" href="#group-chat-related-packets-3" class="paragraph">3</a>In addition to this, a lot of optional data can be stored such as the usernames of friends, our current username, status messages of friends, our status message, etc… can be stored. The exact format of the toxcore save is explained later.</p>
<p><a id="group-chat-related-packets-4" href="#group-chat-related-packets-4" class="paragraph">4</a>The TCP server is run from the toxcore messenger module if the client has enabled it. TCP server is usually run independently as part of the bootstrap node package but it can be enabled in clients. If it is enabled in toxcore, Messenger will add the running TCP server to the TCP relay.</p>
<p><a id="group-chat-related-packets-5" href="#group-chat-related-packets-5" class="paragraph">5</a>Messenger is the module that transforms code that can connect to friends based on public key into a real instant messenger.</p>
<a href="#tcp-client"><h1 id="tcp-client">
<span class="header-section-number">8</span> TCP client</h1></a>
<p><a id="tcp-client-1" href="#tcp-client-1" class="paragraph">1</a><code>TCP client</code> is the client for the TCP server. It establishes and keeps a connection to the TCP server open.</p>
<p><a id="tcp-client-2" href="#tcp-client-2" class="paragraph">2</a>All the packet formats are explained in detail in <code>TCP server</code> so this section will only cover <code>TCP client</code> specific details which are not covered in the <code>TCP server</code> documentation.</p>
<p><a id="tcp-client-3" href="#tcp-client-3" class="paragraph">3</a>TCP clients can choose to connect to TCP servers through a proxy. Most common types of proxies (SOCKS, HTTP) work by establishing a connection through a proxy using the protocol of that specific type of proxy. After the connection through that proxy to a TCP server is established, the socket behaves from the point of view of the application exactly like a TCP socket that connects directly to a TCP server instance. This means supporting proxies is easy.</p>
<p><a id="tcp-client-4" href="#tcp-client-4" class="paragraph">4</a><code>TCP client</code> first establishes a TCP connection, either through a proxy or directly to a TCP server. It uses the DHT public key as its long term key when connecting to the TCP server.</p>
<p><a id="tcp-client-5" href="#tcp-client-5" class="paragraph">5</a>It establishes a secure connection to the TCP server. After establishing a connection to the TCP server, and when the handshake response has been received from the TCP server, the toxcore implementation immediately sends a ping packet. Ideally the first packets sent would be routing request packets but this solution aids code simplicity and allows the server to confirm the connection.</p>
<p><a id="tcp-client-6" href="#tcp-client-6" class="paragraph">6</a>Ping packets, like all other data packets, are sent as encrypted packets.</p>
<p><a id="tcp-client-7" href="#tcp-client-7" class="paragraph">7</a>Ping packets are sent by the toxcore TCP client every 30 seconds with a timeout of 10 seconds, the same interval and timeout as toxcore TCP server ping packets. They are the same because they accomplish the same thing.</p>
<p><a id="tcp-client-8" href="#tcp-client-8" class="paragraph">8</a><code>TCP client</code> must have a mechanism to make sure important packets (routing requests, disconnection notifications, ping packets, ping response packets) don’t get dropped because the TCP socket is full. Should this happen, the TCP client must save these packets and prioritize sending them, in order, when the TCP socket on the server becomes available for writing again. <code>TCP client</code> must also take into account that packets might be bigger than the number of bytes it can currently write to the socket. In this case, it must save the bytes of the packet that it didn’t write to the socket and write them to the socket as soon as the socket allows so that the connection does not get broken. It must also assume that it may receive only part of an encrypted packet. If this occurs it must save the part of the packet it has received and wait for the rest of the packet to arrive before handling it.</p>
<p><a id="tcp-client-9" href="#tcp-client-9" class="paragraph">9</a><code>TCP client</code> can be used to open up a route to friends who are connected to the TCP server. This is done by sending a routing request to the TCP server with the DHT public key of the friend. This tells the server to register a <code>connection_id</code> to the DHT public key sent in the packet. The server will then respond with a routing response packet. If the connection was accepted, the <code>TCP client</code> will store the <code>connection id</code> for this connection. The <code>TCP client</code> will make sure that routing response packets are responses to a routing packet that it sent by storing that it sent a routing packet to that public key and checking the response against it. This prevents the possibility of a bad TCP server exploiting the client.</p>
<p><a id="tcp-client-10" href="#tcp-client-10" class="paragraph">10</a>The <code>TCP client</code> will handle connection notifications and disconnection notifications by alerting the module using it that the connection to the peer is up or down.</p>
<p><a id="tcp-client-11" href="#tcp-client-11" class="paragraph">11</a><code>TCP client</code> will send a disconnection notification to kill a connection to a friend. It must send a disconnection notification packet regardless of whether the peer was online or offline so that the TCP server will unregister the connection.</p>
<p><a id="tcp-client-12" href="#tcp-client-12" class="paragraph">12</a>Data to friends can be sent through the TCP relay using OOB (out of band) packets and connected connections. To send an OOB packet, the DHT public key of the friend must be known. OOB packets are sent in blind and there is no way to query the TCP relay to see if the friend is connected before sending one. OOB packets should be sent when the connection to the friend via the TCP relay isn’t in an connected state but it is known that the friend is connected to that relay. If the friend is connected via the TCP relay, then normal data packets must be sent as they are smaller than OOB packets.</p>
<p><a id="tcp-client-13" href="#tcp-client-13" class="paragraph">13</a>OOB recv and data packets must be handled and passed to the module using it.</p>
<a href="#tcp-connections"><h1 id="tcp-connections">
<span class="header-section-number">9</span> TCP connections</h1></a>
<p><a id="tcp-connections-1" href="#tcp-connections-1" class="paragraph">1</a><code>TCP_connections</code> takes care of handling multiple TCP client instances to establish a reliable connection via TCP relays to a friend. Connecting to a friend with only one relay would not be very reliable, so <code>TCP_connections</code> provides the level of abstraction needed to manage multiple relays. For example, it ensures that if a relay goes down, the connection to the peer will not be impacted. This is done by connecting to the other peer with more than one relay.</p>
<p><a id="tcp-connections-2" href="#tcp-connections-2" class="paragraph">2</a><code>TCP_connections</code> is above <a href="#tcp-client"><code>TCP client</code></a> and below <code>net_crypto</code>.</p>
<p><a id="tcp-connections-3" href="#tcp-connections-3" class="paragraph">3</a>A TCP connection in <code>TCP_connections</code> is defined as a connection to a peer though one or more TCP relays. To connect to another peer with <code>TCP_connections</code>, a connection in <code>TCP_connections</code> to the peer with DHT public key X will be created. Some TCP relays which we know the peer is connected to will then be associated with that peer. If the peer isn’t connected directly yet, these relays will be the ones that the peer has sent to us via the onion module. The peer will also send some relays it is directly connected to once a connection is established, however, this is done by another module.</p>
<p><a id="tcp-connections-4" href="#tcp-connections-4" class="paragraph">4</a><code>TCP_connections</code> has a list of all relays it is connected to. It tries to keep the number of relays it is connected to as small as possible in order to minimize load on relays and lower bandwidth usage for the client. The desired number of TCP relay connections per peer is set to 3 in toxcore with the maximum number set to 6. The reason for these numbers is that 1 would mean no backup relays and 2 would mean only 1 backup. To be sure that the connection is reliable 3 seems to be a reasonable lower bound. The maximum number of 6 is the maximum number of relays that can be tied to each peer. If 2 peers are connected each to the same 6+ relays and they both need to be connected to that amount of relays because of other friends this is where this maximum comes into play. There is no reason why this number is 6 but in toxcore it has to be at least double than the desired number (3) because the code assumes this.</p>
<p><a id="tcp-connections-5" href="#tcp-connections-5" class="paragraph">5</a>If necessary, <code>TCP_connections</code> will connect to TCP relays to use them to send onion packets. This is only done if there is no UDP connection to the network. When there is a UDP connection, packets are sent with UDP only because sending them with TCP relays can be less reliable. It is also important that we are connected at all times to some relays as these relays will be used by TCP only peers to initiate a connection to us.</p>
<p><a id="tcp-connections-6" href="#tcp-connections-6" class="paragraph">6</a>In toxcore, each client is connected to 3 relays even if there are no TCP peers and the onion is not needed. It might be optimal to only connect to these relays when toxcore is initializing as this is the only time when peers will connect to us via TCP relays we are connected to. Due to how the onion works, after the initialization phase, where each peer is searched in the onion and then if they are found the info required to connect back (DHT pk, TCP relays) is sent to them, there should be no more peers connecting to us via TCP relays. This may be a way to further reduce load on TCP relays, however, more research is needed before it is implemented.</p>
<p><a id="tcp-connections-7" href="#tcp-connections-7" class="paragraph">7</a><code>TCP_connections</code> picks one relay and uses only it for sending data to the other peer. The reason for not picking a random connected relay for each packet is that it severely deteriorates the quality of the link between two peers and makes performance of lossy video and audio transmissions really poor. For this reason, one relay is picked and used to send all data. If for any reason no more data can be sent through that relay, the next relay is used. This may happen if the TCP socket is full and so the relay should not necessarily be dropped if this occurs. Relays are only dropped if they time out or if they become useless (if the relay is one too many or is no longer being used to relay data to any peers).</p>
<p><a id="tcp-connections-8" href="#tcp-connections-8" class="paragraph">8</a><code>TCP_connections</code> in toxcore also contains a mechanism to make connections go to sleep. TCP connections to other peers may be put to sleep if the connection to the peer establishes itself with UDP after the connection is established with TCP. UDP is the method preferred by <code>net_crypto</code> to communicate with other peers. In order to keep track of the relays which were used to connect with the other peer in case the UDP connection fails, they are saved by <code>TCP_connections</code> when the connection is put to sleep. Any relays which were only used by this redundant connection are saved then disconnected from. If the connection is awakened, the relays are reconnected to and the connection is reestablished. Putting a connection to sleep is the same as saving all the relays used by the connection and removing the connection. Awakening the connection is the same as creating a new connection with the same parameters and restoring all the relays.</p>
<p><a id="tcp-connections-9" href="#tcp-connections-9" class="paragraph">9</a>A method to detect potentially dysfunctional relays that try to disrupt the network by lying that they are connecting to a peer when they are not or that maliciously drop all packets should be considered. Toxcore doesn’t currently implement such a system and adding one requires more research and likely also requires extending the protocol.</p>
<p><a id="tcp-connections-10" href="#tcp-connections-10" class="paragraph">10</a>When TCP connections connects to a relay it will create a new <a href="#tcp-client"><code>TCP_client</code></a> instance for that relay. At any time if the <code>TCP_client</code> instance reports that it has disconnected, the TCP relay will be dropped. Once the TCP relay reports that it is connected, <code>TCP_connections</code> will find all the connections that are associated to the relay and announce to the relay that it wants to connect to each of them with routing requests. If the relay reports that the peer for a connection is online, the connection number and relay will be used to send data in that connection with data packets. If the peer isn’t reported as online but the relay is associated to a connection, TCP OOB (out of band) packets will be used to send data instead of data packets. TCP OOB packets are used in this case since the relay most likely has the peer connected but it has not sent a routing request to connect to us.</p>
<p><a id="tcp-connections-11" href="#tcp-connections-11" class="paragraph">11</a><code>TCP_connections</code> is used as the bridge between individual <code>TCP_client</code> instances and <code>net_crypto</code>, or the bridge between individual connections and something that requires an interface that looks like one connection.</p>
<a href="#tcp-server"><h1 id="tcp-server">
<span class="header-section-number">10</span> TCP server</h1></a>
<p><a id="tcp-server-1" href="#tcp-server-1" class="paragraph">1</a>The TCP server in tox has the goal of acting like a TCP relay between clients who cannot connect directly to each other or who for some reason are limited to using the TCP protocol to connect to each other. <code>TCP_server</code> is typically run only on actual server machines but any Tox client could host one as the api to run one is exposed through the tox.h api.</p>
<p><a id="tcp-server-2" href="#tcp-server-2" class="paragraph">2</a>To connect to a hosted TCP server toxcore uses the TCP client module.</p>
<p><a id="tcp-server-3" href="#tcp-server-3" class="paragraph">3</a>The TCP server implementation in toxcore can currently either work on epoll on linux or using unoptimized but portable socket polling.</p>
<p><a id="tcp-server-4" href="#tcp-server-4" class="paragraph">4</a>TCP connections between the TCP client and the server are encrypted to prevent an outsider from knowing information like who is connecting to who just be looking at someones connection to a TCP server. This is useful when someone connects though something like Tor for example. It also prevents someone from injecting data in the stream and makes it so we can assume that any data received was not tampered with and is exactly what was sent by the client.</p>
<p><a id="tcp-server-5" href="#tcp-server-5" class="paragraph">5</a>When a client first connects to a TCP server he opens up a TCP connection to the ip and port the TCP server is listening on. Once the connection is established he then sends a handshake packet, the server then responds with his own and a secure connection is established. The connection is then said to be unconfirmed and the client must then send some encrypted data to the server before the server can mark the connection as confirmed. The reason it works like this is to prevent a type of attack where a peer would send a handshake packet and then time out right away. To prevent this the server must wait a few seconds for a sign that the client received his handshake packet before confirming the connection. The both can then communicate with each other using the encrypted connection.</p>
<p><a id="tcp-server-6" href="#tcp-server-6" class="paragraph">6</a>The TCP server essentially acts as just a relay between 2 peers. When a TCP client connects to the server he tells the server which clients he wants the server to connect him to. The server will only let two clients connect to each other if both have indicated to the server that they want to connect to each other. This is to prevent non friends from checking if someone is connected to a TCP server. The TCP server supports sending packets blindly through it to clients with a client with public key X (OOB packets) however the TCP server does not give any feedback or anything to say if the packet arrived or not and as such it is only useful to send data to friends who may not know that we are connected to the current TCP server while we know they are. This occurs when one peer discovers the TCP relay and DHT public key of the other peer before the other peer discovers its DHT public key. In that case OOB packets would be used until the other peer knows that the peer is connected to the relay and establishes a connection through it.</p>
<p><a id="tcp-server-7" href="#tcp-server-7" class="paragraph">7</a>In order to make toxcore work on TCP only the TCP server supports relaying onion packets from TCP clients and sending any responses from them to TCP clients.</p>
<p><a id="tcp-server-8" href="#tcp-server-8" class="paragraph">8</a>To establish a secure connection with a TCP server send the following 128 bytes of data or handshake packet to the server:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">DHT public key of client</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce for the encrypted data</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>72</code></td>
<td style="text-align: left;">Payload (plus MAC)</td>
</tr>
</tbody>
</table>
<p><a id="tcp-server-9" href="#tcp-server-9" class="paragraph">9</a>Payload is encrypted with the DHT private key of the client and public key of the server and the nonce:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public key</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Base nonce</td>
</tr>
</tbody>
</table>
<p><a id="tcp-server-10" href="#tcp-server-10" class="paragraph">10</a>The base nonce is the one TCP client wants the TCP server to use to encrypt the packets sent to the TCP client.</p>
<p><a id="tcp-server-11" href="#tcp-server-11" class="paragraph">11</a>The first 32 bytes are the public key (DHT public key) that the TCP client is announcing itself to the server with. The next 24 bytes are a nonce which the TCP client uses along with the secret key associated with the public key in the first 32 bytes of the packet to encrypt the rest of this ‘packet’. The encrypted part of this packet contains a temporary public key that will be used for encryption during the connection and will be discarded after. It also contains a base nonce which will be used later for encrypting packets sent to the TCP client.</p>
<p><a id="tcp-server-12" href="#tcp-server-12" class="paragraph">12</a>If the server decrypts successfully the encrypted data in the handshake packet and responds with the following handshake response of length 96 bytes:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce for the encrypted data</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>72</code></td>
<td style="text-align: left;">Payload (plus MAC)</td>
</tr>
</tbody>
</table>
<p><a id="tcp-server-13" href="#tcp-server-13" class="paragraph">13</a>Payload is encrypted with the private key of the server and the DHT public key of the client and the nonce:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public key</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Base nonce</td>
</tr>
</tbody>
</table>
<p><a id="tcp-server-14" href="#tcp-server-14" class="paragraph">14</a>The base nonce is the one the TCP server wants the TCP client to use to encrypt the packets sent to the TCP server.</p>
<p><a id="tcp-server-15" href="#tcp-server-15" class="paragraph">15</a>The client already knows the long term public key of the server so it is omitted in the response, instead only a nonce is present in the unencrypted part. The encrypted part of the response has the same elements as the encrypted part of the request: a temporary public key tied to this connection and a base nonce which will be used later when decrypting packets received from the TCP client both unique for the connection.</p>
<p><a id="tcp-server-16" href="#tcp-server-16" class="paragraph">16</a>In toxcore the base nonce is generated randomly like all the other nonces, it must be randomly generated to prevent nonce reuse. For example if the nonce used was 0 for both sides since both sides use the same keys to encrypt packets they send to each other, two packets would be encrypted with the same nonce. These packets could then be possibly replayed back to the sender which would cause issues. A similar mechanism is used in <code>net_crypto</code>.</p>
<p><a id="tcp-server-17" href="#tcp-server-17" class="paragraph">17</a>After this the client will know the connection temporary public key and base nonce of the server and the server will know the connection base nonce and temporary public key of the client.</p>
<p><a id="tcp-server-18" href="#tcp-server-18" class="paragraph">18</a>The client will then send an encrypted packet to the server, the contents of the packet do not matter and it must be handled normally by the server (ex: if it was a ping send a pong response. The first packet must be any valid encrypted data packet), the only thing that does matter is that the packet was encrypted correctly by the client because it means that the client has correctly received the handshake response the server sent to it and that the handshake the client sent to the server really came from the client and not from an attacker replaying packets. The server must prevent resource consuming attacks by timing out clients if they do not send any encrypted packets so the server to prove to the server that the connection was established correctly.</p>
<p><a id="tcp-server-19" href="#tcp-server-19" class="paragraph">19</a>Toxcore does not have a timeout for clients, instead it stores connecting clients in large circular lists and times them out if their entry in the list gets replaced by a newer connection. The reasoning behind this is that it prevents TCP flood attacks from having a negative impact on the currently connected nodes. There are however much better ways to do this and the only reason toxcore does it this way is because writing it was very simple. When connections are confirmed they are moved somewhere else.</p>
<p><a id="tcp-server-20" href="#tcp-server-20" class="paragraph">20</a>When the server confirms the connection he must look in the list of connected peers to see if he is already connected to a client with the same announced public key. If this is the case the server must kill the previous connection because this means that the client previously timed out and is reconnecting. Because of Toxcore design it is very unlikely to happen that two legitimate different peers will have the same public key so this is the correct behavior.</p>
<p><a id="tcp-server-21" href="#tcp-server-21" class="paragraph">21</a>Encrypted data packets look like this to outsiders:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> length of data</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">encrypted data</td>
</tr>
</tbody>
</table>
<p><a id="tcp-server-22" href="#tcp-server-22" class="paragraph">22</a>In a TCP stream they would look like: <code>[[length][data]][[length][data]][[length][data]]...</code>.</p>
<p><a id="tcp-server-23" href="#tcp-server-23" class="paragraph">23</a>Both the client and server use the following (temp public and private (client and server) connection keys) which are each generated for the connection and then sent to the other in the handshake and sent to the other. They are then used like the next diagram shows to generate a shared key which is equal on both sides.</p>
<pre><code>Client:                                     Server:
generate_shared_key(                        generate_shared_key(
[temp connection public key of server],     [temp connection public key of client],
[temp connection private key of client])    [temp connection private key of server])
=                                           =
[shared key]                                [shared key]</code></pre>
<p><a id="tcp-server-24" href="#tcp-server-24" class="paragraph">24</a>The generated shared key is equal on both sides and is used to encrypt and decrypt the encrypted data packets.</p>
<p><a id="tcp-server-25" href="#tcp-server-25" class="paragraph">25</a>each encrypted data packet sent to the client will be encrypted with the shared key and with a nonce equal to: (client base nonce + number of packets sent so for the first packet it is (starting at 0) nonce + 0, the second is nonce + 1 and so on. Note that nonces like all other numbers sent over the network in toxcore are numbers in big endian format so when increasing them by 1 the least significant byte is the last one)</p>
<p><a id="tcp-server-26" href="#tcp-server-26" class="paragraph">26</a>each packet received from the client will be decrypted with the shared key and with a nonce equal to: (server base nonce + number of packets sent so for the first packet it is (starting at 0) nonce + 0, the second is nonce + 1 and so on. Note that nonces like all other numbers sent over the network in toxcore are numbers in big endian format so when increasing them by 1 the least significant byte is the last one)</p>
<p><a id="tcp-server-27" href="#tcp-server-27" class="paragraph">27</a>Encrypted data packets have a hard maximum size of 2 + 2048 bytes in the toxcore TCP server implementation, 2048 bytes is big enough to make sure that all toxcore packets can go through and leaves some extra space just in case the protocol needs to be changed in the future. The 2 bytes represents the size of the data length and the 2048 bytes the max size of the encrypted part. This means the maximum size is 2050 bytes. In current toxcore, the largest encrypted data packets sent will be of size 2 + 1417 which is 1419 total.</p>
<p><a id="tcp-server-28" href="#tcp-server-28" class="paragraph">28</a>The logic behind the format of the handshake is that we:</p>
<ol type="1">
<li>need to prove to the server that we own the private key related to the public key we are announcing ourselves with.</li>
<li>need to establish a secure connection that has perfect forward secrecy</li>
<li>prevent any replay, impersonation or other attacks</li>
</ol>
<p><a id="tcp-server-29" href="#tcp-server-29" class="paragraph">29</a>How it accomplishes each of those points:</p>
<ol type="1">
<li>If the client does not own the private key related to the public key they will not be able to create the handshake packet.</li>
<li>Temporary session keys generated by the client and server in the encrypted part of the handshake packets are used to encrypt/decrypt packets during the session.</li>
<li>The following attacks are prevented:
<ul>
<li>Attacker modifies any byte of the handshake packets: Decryption fail, no attacks possible.</li>
<li>Attacker captures the handshake packet from the client and replays it later to the server: Attacker will never get the server to confirm the connection (no effect).</li>
<li>Attacker captures a server response and sends it to the client next time they try to connect to the server: Client will never confirm the connection. (See: <code>TCP_client</code>)</li>
<li>Attacker tries to impersonate a server: They won’t be able to decrypt the handshake and won’t be able to respond.</li>
<li>Attacker tries to impersonate a client: Server won’t be able to decrypt the handshake.</li>
</ul>
</li>
</ol>
<p><a id="tcp-server-30" href="#tcp-server-30" class="paragraph">30</a>The logic behind the format of the encrypted packets is that:</p>
<ol type="1">
<li>TCP is a stream protocol, we need packets.</li>
<li>Any attacks must be prevented</li>
</ol>
<p><a id="tcp-server-31" href="#tcp-server-31" class="paragraph">31</a>How it accomplishes each of those points:</p>
<ol type="1">
<li>2 bytes before each packet of encrypted data denote the length. We assume a functioning TCP will deliver bytes in order which makes it work. If the TCP doesn’t it most likely means it is under attack and for that see the next point.</li>
<li>The following attacks are prevented:
<ul>
<li>Modifying the length bytes will either make the connection time out and/or decryption fail.</li>
<li>Modifying any encrypted bytes will make decryption fail.</li>
<li>Injecting any bytes will make decryption fail.</li>
<li>Trying to re order the packets will make decryption fail because of the ordered nonce.</li>
<li>Removing any packets from the stream will make decryption fail because of the ordered nonce.</li>
</ul>
</li>
</ol>
<a href="#encrypted-payload-types"><h2 id="encrypted-payload-types">
<span class="header-section-number">10.1</span> Encrypted payload types</h2></a>
<p><a id="encrypted-payload-types-1" href="#encrypted-payload-types-1" class="paragraph">1</a>The folowing represents the various types of data that can be sent inside encrypted data packets.</p>
<a href="#routing-request-0x00"><h3 id="routing-request-0x00">
<span class="header-section-number">10.1.1</span> Routing request (0x00)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x00)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public key</td>
</tr>
</tbody>
</table>
<a href="#routing-request-response-0x01"><h3 id="routing-request-response-0x01">
<span class="header-section-number">10.1.2</span> Routing request response (0x01)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x01)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> rpid</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public key</td>
</tr>
</tbody>
</table>
<p><a id="routing-request-response-0x01-1" href="#routing-request-response-0x01-1" class="paragraph">1</a>rpid is invalid <code>connection_id</code> (0) if refused, <code>connection_id</code> if accepted.</p>
<a href="#connect-notification-0x02"><h3 id="connect-notification-0x02">
<span class="header-section-number">10.1.3</span> Connect notification (0x02)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x02)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> <code>connection_id</code> of connection that got connected</td>
</tr>
</tbody>
</table>
<a href="#disconnect-notification-0x03"><h3 id="disconnect-notification-0x03">
<span class="header-section-number">10.1.4</span> Disconnect notification (0x03)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x03)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> <code>connection_id</code> of connection that got disconnected</td>
</tr>
</tbody>
</table>
<a href="#ping-packet-0x04"><h3 id="ping-packet-0x04">
<span class="header-section-number">10.1.5</span> Ping packet (0x04)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x04)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">
<code>uint64_t</code> <code>ping_id</code> (0 is invalid)</td>
</tr>
</tbody>
</table>
<a href="#ping-response-pong-0x05"><h3 id="ping-response-pong-0x05">
<span class="header-section-number">10.1.6</span> Ping response (pong) (0x05)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x05)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">
<code>uint64_t</code> <code>ping_id</code> (0 is invalid)</td>
</tr>
</tbody>
</table>
<a href="#oob-send-0x06"><h3 id="oob-send-0x06">
<span class="header-section-number">10.1.7</span> OOB send (0x06)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x06)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Destination public key</td>
</tr>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Data</td>
</tr>
</tbody>
</table>
<a href="#oob-recv-0x07"><h3 id="oob-recv-0x07">
<span class="header-section-number">10.1.8</span> OOB recv (0x07)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x07)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Sender public key</td>
</tr>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Data</td>
</tr>
</tbody>
</table>
<a href="#onion-packet-0x08"><h3 id="onion-packet-0x08">
<span class="header-section-number">10.1.9</span> Onion packet (0x08)</h3></a>
<p><a id="onion-packet-0x08-1" href="#onion-packet-0x08-1" class="paragraph">1</a>Same format as initial onion packet but packet id is 0x08 instead of 0x80.</p>
<a href="#onion-packet-response-0x09"><h3 id="onion-packet-response-0x09">
<span class="header-section-number">10.1.10</span> Onion packet response (0x09)</h3></a>
<p><a id="onion-packet-response-0x09-1" href="#onion-packet-response-0x09-1" class="paragraph">1</a>Same format as onion packet but packet id is 0x09 instead of 0x8e.</p>
<a href="#data-0x10-and-up"><h3 id="data-0x10-and-up">
<span class="header-section-number">10.1.11</span> Data (0x10 and up)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> packet id</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> connection id</td>
</tr>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">data</td>
</tr>
</tbody>
</table>
<p><a id="data-0x10-and-up-1" href="#data-0x10-and-up-1" class="paragraph">1</a>The TCP server is set up in a way to minimize waste while relaying the many packets that might go between two tox peers hence clients must create connections to other clients on the relay. The connection number is a <code>uint8_t</code> and must be equal or greater to 16 in order to be valid. Because a <code>uint8_t</code> has a maximum value of 256 it means that the maximum number of different connections to other clients that each connection can have is 240. The reason valid <code>connection_ids</code> are bigger than 16 is because they are the first byte of data packets. Currently only number 0 to 9 are taken however we keep a few extras in case we need to extend the protocol without breaking it completely.</p>
<p><a id="data-0x10-and-up-2" href="#data-0x10-and-up-2" class="paragraph">2</a>Routing request (Sent by client to server): Send a routing request to the server that we want to connect to peer with public key where the public key is the public the peer announced themselves as. The server must respond to this with a Routing response.</p>
<p><a id="data-0x10-and-up-3" href="#data-0x10-and-up-3" class="paragraph">3</a>Routing response (Sent by server to client): The response to the routing request, tell the client if the routing request succeeded (valid <code>connection_id</code>) and if it did, tell them the id of the connection (<code>connection_id</code>). The public key sent in the routing request is also sent in the response so that the client can send many requests at the same time to the server without having code to track which response belongs to which public key.</p>
<p><a id="data-0x10-and-up-4" href="#data-0x10-and-up-4" class="paragraph">4</a>The only reason a routing request should fail is if the connection has reached the maximum number of simultaneous connections. In case the routing request fails the public key in the response will be the public key in the failed request.</p>
<p><a id="data-0x10-and-up-5" href="#data-0x10-and-up-5" class="paragraph">5</a>Connect notification (Sent by server to client): Tell the client that <code>connection_id</code> is now connected meaning the other is online and data can be sent using this <code>connection_id</code>.</p>
<p><a id="data-0x10-and-up-6" href="#data-0x10-and-up-6" class="paragraph">6</a>Disconnect notification (Sent by client to server): Sent when client wants the server to forget about the connection related to the <code>connection_id</code> in the notification. Server must remove this connection and must be able to reuse the <code>connection_id</code> for another connection. If the connection was connected the server must send a disconnect notification to the other client. The other client must think that this client has simply disconnected from the TCP server.</p>
<p><a id="data-0x10-and-up-7" href="#data-0x10-and-up-7" class="paragraph">7</a>Disconnect notification (Sent by server to client): Sent by the server to the client to tell them that the connection with <code>connection_id</code> that was connected is now disconnect. It is sent either when the other client of the connection disconnect or when they tell the server to kill the connection (see above).</p>
<p><a id="data-0x10-and-up-8" href="#data-0x10-and-up-8" class="paragraph">8</a>Ping and Pong packets (can be sent by both client and server, both will respond): ping packets are used to know if the other side of the connection is still live. TCP when established doesn’t have any sane timeouts (1 week isn’t sane) so we are obliged to have our own way to check if the other side is still live. Ping ids can be anything except 0, this is because of how toxcore sets the variable storing the <code>ping_id</code> that was sent to 0 when it receives a pong response which means 0 is invalid.</p>
<p><a id="data-0x10-and-up-9" href="#data-0x10-and-up-9" class="paragraph">9</a>The server should send ping packets every X seconds (toxcore <code>TCP_server</code> sends them every 30 seconds and times out the peer if it doesn’t get a response in 10). The server should respond immediately to ping packets with pong packets.</p>
<p><a id="data-0x10-and-up-10" href="#data-0x10-and-up-10" class="paragraph">10</a>The server should respond to ping packets with pong packets with the same <code>ping_id</code> as was in the ping packet. The server should check that each pong packet contains the same <code>ping_id</code> as was in the ping, if not the pong packet must be ignored.</p>
<p><a id="data-0x10-and-up-11" href="#data-0x10-and-up-11" class="paragraph">11</a>OOB send (Sent by client to server): If a peer with private key equal to the key they announced themselves with is connected, the data in the OOB send packet will be sent to that peer as an OOB recv packet. If no such peer is connected, the packet is discarded. The toxcore <code>TCP_server</code> implementation has a hard maximum OOB data length of 1024. 1024 was picked because it is big enough for the <code>net_crypto</code> packets related to the handshake and is large enough that any changes to the protocol would not require breaking TCP server. It is however not large enough for the biggest <code>net_crypto</code> packets sent with an established <code>net_crypto</code> connection to prevent sending those via OOB packets.</p>
<p><a id="data-0x10-and-up-12" href="#data-0x10-and-up-12" class="paragraph">12</a>OOB recv (Sent by server to client): OOB recv are sent with the announced public key of the peer that sent the OOB send packet and the exact data.</p>
<p><a id="data-0x10-and-up-13" href="#data-0x10-and-up-13" class="paragraph">13</a>OOB packets can be used just like normal data packets however the extra size makes sending data only through them less efficient than data packets.</p>
<p><a id="data-0x10-and-up-14" href="#data-0x10-and-up-14" class="paragraph">14</a>Data: Data packets can only be sent and received if the corresponding <code>connection_id</code> is connection (a Connect notification has been received from it) if the server receives a Data packet for a non connected or existent connection it will discard it.</p>
<p><a id="data-0x10-and-up-15" href="#data-0x10-and-up-15" class="paragraph">15</a>Why did I use different packet ids for all packets when some are only sent by the client and some only by the server? It’s less confusing.</p>
<a href="#friend-connection"><h1 id="friend-connection">
<span class="header-section-number">11</span> Friend connection</h1></a>
<p><a id="friend-connection-1" href="#friend-connection-1" class="paragraph">1</a><code>friend_connection</code> is the module that sits on top of the DHT, onion and <code>net_crypto</code> modules and takes care of linking the 3 together.</p>
<p><a id="friend-connection-2" href="#friend-connection-2" class="paragraph">2</a>Friends in <code>friend_connection</code> are represented by their real public key. When a friend is added in <code>friend_connection</code>, an onion search entry is created for that friend. This means that the onion module will start looking for this friend and send that friend their DHT public key, and the TCP relays it is connected to, in case a connection is only possible with TCP.</p>
<p><a id="friend-connection-3" href="#friend-connection-3" class="paragraph">3</a>Once the onion returns the DHT public key of the peer, the DHT public key is saved, added to the DHT friends list and a new <code>net_crypto</code> connection is created. Any TCP relays returned by the onion for this friend are passed to the <code>net_crypto</code> connection.</p>
<p><a id="friend-connection-4" href="#friend-connection-4" class="paragraph">4</a>If the DHT establishes a direct UDP connection with the friend, <code>friend_connection</code> will pass the IP/port of the friend to <code>net_crypto</code> and also save it to be used to reconnect to the friend if they disconnect.</p>
<p><a id="friend-connection-5" href="#friend-connection-5" class="paragraph">5</a>If <code>net_crypto</code> finds that the friend has a different DHT public key, which can happen if the friend restarted their client, <code>net_crypto</code> will pass the new DHT public key to the onion module and will remove the DHT entry for the old DHT public key and replace it with the new one. The current <code>net_crypto</code> connection will also be killed and a new one with the correct DHT public key will be created.</p>
<p><a id="friend-connection-6" href="#friend-connection-6" class="paragraph">6</a>When the <code>net_crypto</code> connection for a friend goes online, <code>friend_connection</code> will tell the onion module that the friend is online so that it can stop spending resources looking for the friend. When the friend connection goes offline, <code>friend_connection</code> will tell the onion module so that it can start looking for the friend again.</p>
<p><a id="friend-connection-7" href="#friend-connection-7" class="paragraph">7</a>There are 2 types of data packets sent to friends with the <code>net_crypto</code> connection handled at the level of <code>friend_connection</code>, Alive packets and TCP relay packets. Alive packets are packets with the packet id or first byte of data (only byte in this packet) being 16. They are used in order to check if the other friend is still online. <code>net_crypto</code> does not have any timeout when the connection is established so timeouts are caught using this packet. In toxcore, this packet is sent every 8 seconds. If none of these packets are received for 32 seconds, the connection is timed out and killed. These numbers seem to cause the least issues and 32 seconds is not too long so that, if a friend times out, toxcore won’t falsely see them online for too long. Usually when a friend goes offline they have time to send a disconnect packet in the <code>net_crypto</code> connection which makes them appear offline almost instantly.</p>
<p><a id="friend-connection-8" href="#friend-connection-8" class="paragraph">8</a>The timeout for when to stop retrying to connect to a friend by creating new <code>net_crypto</code> connections when the old one times out in toxcore is the same as the timeout for DHT peers (122 seconds). However, it is calculated from the last time a DHT public key was received for the friend or time the friend’s <code>net_crypto</code> connection went offline after being online. The highest time is used to calculate when the timeout is. <code>net_crypto</code> connections will be recreated (if the connection fails) until this timeout.</p>
<p><a id="friend-connection-9" href="#friend-connection-9" class="paragraph">9</a><code>friend_connection</code> sends a list of 3 relays (the same number as the target number of TCP relay connections in <code>TCP_connections</code>) to each connected friend every 5 minutes in toxcore. Immediately before sending the relays, they are associated to the current <code>net_crypto-&gt;TCP_connections</code> connection. This facilitates connecting the two friends together using the relays as the friend who receives the packet will associate the sent relays to the <code>net_crypto</code> connection they received it from. When both sides do this they will be able to connect to each other using the relays. The packet id or first byte of the packet of share relay packets is 0x11. This is then followed by some TCP relays stored in packed node format.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x11)</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">TCP relays in packed node format (see DHT)</td>
</tr>
</tbody>
</table>
<p><a id="friend-connection-10" href="#friend-connection-10" class="paragraph">10</a>If local IPs are received as part of the packet, the local IP will be replaced with the IP of the peer that sent the relay. This is because we assume this is the best way to attempt to connect to the TCP relay. If the peer that sent the relay is using a local IP, then the sent local IP should be used to connect to the relay.</p>
<p><a id="friend-connection-11" href="#friend-connection-11" class="paragraph">11</a>For all other data packets, are passed by <code>friend_connection</code> up to the upper Messenger module. It also separates lossy and lossless packets from <code>net_crypto</code>.</p>
<p><a id="friend-connection-12" href="#friend-connection-12" class="paragraph">12</a>Friend connection takes care of establishing the connection to the friend and gives the upper messenger layer a simple interface to receive and send messages, add and remove friends and know if a friend is connected (online) or not connected (offline).</p>
<a href="#friend-requests"><h1 id="friend-requests">
<span class="header-section-number">12</span> Friend requests</h1></a>
<p><a id="friend-requests-1" href="#friend-requests-1" class="paragraph">1</a>When a Tox user adds someone with Tox, toxcore will try sending a friend request to that person. A friend request contains the long term public key of the sender, a nospam number and a message.</p>
<p><a id="friend-requests-2" href="#friend-requests-2" class="paragraph">2</a>Transmitting the long term public key is the primary goal of the friend request as it is what the peer needs to find and establish a connection to the sender. The long term public key is what the receiver adds to his friends list if he accepts the friend request.</p>
<p><a id="friend-requests-3" href="#friend-requests-3" class="paragraph">3</a>The nospam is a number used to prevent someone from spamming the network with valid friend requests. It makes sure that the only people who have seen the Tox ID of a peer are capable of sending them a friend request. The nospam is one of the components of the Tox ID.</p>
<p><a id="friend-requests-4" href="#friend-requests-4" class="paragraph">4</a>The nospam is a number or a list of numbers set by the peer, only received friend requests that contain a nospam that was set by the peer are sent to the client to be accepted or refused by the user. The nospam prevents random peers in the network from sending friend requests to non friends. The nospam is not long enough to be secure meaning an extremely resilient attacker could manage to send a spam friend request to someone. 4 bytes is large enough to prevent spam from random peers in the network. The nospam could also allow Tox users to issue different Tox IDs and even change Tox IDs if someone finds a Tox ID and decides to send it hundreds of spam friend requests. Changing the nospam would stop the incoming wave of spam friend requests without any negative effects to the users friends list. For example if users would have to change their public key to prevent them from receiving friend requests it would mean they would have to essentially abandon all their current friends as friends are tied to the public key. The nospam is not used at all once the friends have each other added which means changing it won’t have any negative effects.</p>
<p><a id="friend-requests-5" href="#friend-requests-5" class="paragraph">5</a>Friend request:</p>
<pre><code>[uint32_t nospam][Message (UTF8) 1 to ONION_CLIENT_MAX_DATA_SIZE bytes]</code></pre>
<p><a id="friend-requests-6" href="#friend-requests-6" class="paragraph">6</a>Friend request packet when sent as an onion data packet:</p>
<pre><code>[uint8_t (32)][Friend request]</code></pre>
<p><a id="friend-requests-7" href="#friend-requests-7" class="paragraph">7</a>Friend request packet when sent as a <code>net_crypto</code> data packet (If we are directly connected to the peer because of a group chat but are not friends with them):</p>
<pre><code>[uint8_t (18)][Friend request]</code></pre>
<p><a id="friend-requests-8" href="#friend-requests-8" class="paragraph">8</a>When a friend is added to toxcore with their Tox ID and a message, the friend is added in <code>friend_connection</code> and then toxcore tries to send friend requests.</p>
<p><a id="friend-requests-9" href="#friend-requests-9" class="paragraph">9</a>When sending a friend request, toxcore will check if the peer which a friend request is being sent to is already connected to using a <code>net_crypto</code> connection which can happen if both are in the same group chat. If this is the case the friend request will be sent as a <code>net_crypto</code> packet using that connection. If not, it will be sent as an onion data packet.</p>
<p><a id="friend-requests-10" href="#friend-requests-10" class="paragraph">10</a>Onion data packets contain the real public key of the sender and if a <code>net_crypto</code> connection is established it means the peer knows our real public key. This is why the friend request does not need to contain the real public key of the peer.</p>
<p><a id="friend-requests-11" href="#friend-requests-11" class="paragraph">11</a>Friend requests are sent with exponentially increasing interval of 2 seconds, 4 seconds, 8 seconds, etc… in toxcore. This is so friend requests get resent but eventually get resent in intervals that are so big that they essentially expire. The sender has no way of knowing if a peer refuses a friend requests which is why friend requests need to expire in some way. Note that the interval is the minimum timeout, if toxcore cannot send that friend request it will try again until it manages to send it. One reason for not being able to send the friend request would be that the onion has not found the friend in the onion and so cannot send an onion data packet to them.</p>
<p><a id="friend-requests-12" href="#friend-requests-12" class="paragraph">12</a>Received friend requests are passed to the client, the client is expected to show the message from the friend request to the user and ask the user if they want to accept the friend request or not. Friend requests are accepted by adding the peer sending the friend request as a friend and refused by simply ignoring it.</p>
<p><a id="friend-requests-13" href="#friend-requests-13" class="paragraph">13</a>Friend requests are sent multiple times meaning that in order to prevent the same friend request from being sent to the client multiple times toxcore keeps a list of the last real public keys it received friend requests from and discards any received friend requests that are from a real public key that is in that list. In toxcore this list is a simple circular list. There are many ways this could be improved and made more efficient as a circular list isn’t very efficient however it has worked well in toxcore so far.</p>
<p><a id="friend-requests-14" href="#friend-requests-14" class="paragraph">14</a>Friend requests from public keys that are already added to the friends list should also be discarded.</p>
<a href="#group"><h1 id="group">
<span class="header-section-number">13</span> Group</h1></a>
<p><a id="group-1" href="#group-1" class="paragraph">1</a>Group chats in Tox work by temporarily adding some peers (up to 4) present in the group chat as temporary <code>friend_connection</code> friends, that are deleted when the group chat is exited.</p>
<p><a id="group-2" href="#group-2" class="paragraph">2</a>Each peer in the group chat is identified by their real long term public key however peers transmit their DHT public keys to each other via the group chat in order to speed up the connection by making it unnecessary for the peers to find each others DHT public keys with the onion which would happen if they would have added themselves as normal friends.</p>
<p><a id="group-3" href="#group-3" class="paragraph">3</a>The upside of using <code>friend_connection</code> is that group chats do not have to deal with things like hole punching, peers only on TCP or other low level networking things. The downside however is that every single peer knows each others real long term public key and DHT public key which means these group chats should only be used between friends.</p>
<p><a id="group-4" href="#group-4" class="paragraph">4</a>To connect to each other, two peers must have the other added to their list of friend connections. This is not a problem if the group chat has an equal or smaller number of participants than 5 as each of the 5 peers will have the 4 others added to their list of friend connections. When there are more peers there must be a way to ensure that peers will manage to connect to other groupchat peers.</p>
<p><a id="group-5" href="#group-5" class="paragraph">5</a>Since the maximum number of peers per groupchat that will be connected to with friend connections is 4, if all peers in the groupchat are arranged in a perfect circle and each peer connects to the 2 peers that are the closest to the right of them and the 2 peers that are closest to the left of them, the peers should form a well connected circle of peers.</p>
<p><a id="group-6" href="#group-6" class="paragraph">6</a>Group chats in toxcore do this by subtracting the real long term public key of the peer with all the others in the group (our PK - other peer PK) and finding the two peers for which the result of this operation is the smallest. The operation is then inversed (other peer PK - our PK) and this operation is done again with all the public keys of the peers in the group. The 2 peers for which the result is again the smallest are picked.</p>
<p><a id="group-7" href="#group-7" class="paragraph">7</a>This gives 4 peers that are then added as a friend connection and associated to the group. If every peer in the group does this, they will form a circle of perfectly connected peers.</p>
<p><a id="group-8" href="#group-8" class="paragraph">8</a>Once the peers are connected to each other in a circle they relay each others messages. Every time a peer leaves the group or a new peer joins each member of the chat will recalculate the peers they should connect to.</p>
<p><a id="group-9" href="#group-9" class="paragraph">9</a>To join a group chat the peer must first be invited to it by their friend. To make a groupchat the peer will first create a groupchat and then invite people to this group chat. Once their friends are in the group chat they can invite their other friends to the chat and so on.</p>
<p><a id="group-10" href="#group-10" class="paragraph">10</a>To create a group chat the peer will generate a random 32 byte id that will be used to uniquely identify this group chat. 32 bytes is enough so that when randomly generated with a secure random number generator every groupchat ever created will have a different id. The goal of this 32 byte id is so that peers have a way of identifying each group chat so that they can prevent themselves from joining a groupchat twice for example.</p>
<p><a id="group-11" href="#group-11" class="paragraph">11</a>The groupchat will also have an unsigned 1 byte type. This type indicates what kind of groupchat the groupchat is, the current types are:</p>
<p><a id="group-12" href="#group-12" class="paragraph">12</a>0: text 1: audio</p>
<p><a id="group-13" href="#group-13" class="paragraph">13</a>Text groupchats are text only while audio indicates that the groupchat supports sending audio to it as well as text.</p>
<p><a id="group-14" href="#group-14" class="paragraph">14</a>The groupchat will also be identified by a unique unsigned 2 byte integer which in toxcore corresponds to the index of the groupchat in the array it is being stored in. Every groupchat in the current instance must have a different number. This number is used by groupchat peers that are directly connected to us to tell us which packets are for which groupchat. This is why every groupchat packet contains a groupchat number as part of them. Putting a 32 byte groupchat id in each packet would increase bandwidth waste by a lot which is the reason why groupchat numbers are used instead.</p>
<p><a id="group-15" href="#group-15" class="paragraph">15</a>Using the group number as the index of the array used to store the groupchat instances is recommended because this kind of access is usually most efficient and it ensures that each groupchat has a unique group number.</p>
<p><a id="group-16" href="#group-16" class="paragraph">16</a>When creating a new groupchat, the peer will add themselves as a groupchat peer with a peer number of 0 and their own long term public key and DHT public key.</p>
<p><a id="group-17" href="#group-17" class="paragraph">17</a>Invite packets:</p>
<p><a id="group-18" href="#group-18" class="paragraph">18</a>Invite packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x60)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x00)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>33</code></td>
<td style="text-align: left;">Group chat identifier</td>
</tr>
</tbody>
</table>
<p><a id="group-19" href="#group-19" class="paragraph">19</a>A group chat identifier consists of a 1-byte type and a 32-byte ID concatenated.</p>
<p><a id="group-20" href="#group-20" class="paragraph">20</a>Response packet</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x60)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x01)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number (local)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number to join</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>33</code></td>
<td style="text-align: left;">Group chat identifier</td>
</tr>
</tbody>
</table>
<p><a id="group-21" href="#group-21" class="paragraph">21</a>To invite a friend to a group chat, an invite packet is sent to the friend. These packets are sent using Messenger (if you look at the Messenger packet id section, all the groupchat packet ids are in there). Note that all numbers like all other numbers sent using Tox packets are sent in big endian format.</p>
<p><a id="group-22" href="#group-22" class="paragraph">22</a>The group chat number is as explained above, the number used to uniquely identify the groupchat instance from all the other groupchat instances the peer has. It is sent in the invite packet because it is needed by the friend in order to send back groupchat related packets.</p>
<p><a id="group-23" href="#group-23" class="paragraph">23</a>What follows is the 1 byte type with the 32 byte groupchat id appended to it.</p>
<p><a id="group-24" href="#group-24" class="paragraph">24</a>To refuse the invite, the friend receiving it will simply ignore and discard it.</p>
<p><a id="group-25" href="#group-25" class="paragraph">25</a>To accept the invite, the friend will create their own groupchat instance with the 32 byte groupchat id and 1 byte type sent in the request and send a invite response packet back. The friend will also add the one who sent the invite as a temporary invited groupchat connection.</p>
<p><a id="group-26" href="#group-26" class="paragraph">26</a>The first group number in the response packet is the group number of the groupchat the invited friend just created. The second group number is the group chat number that was sent in the invite request. What follows is the 1 byte type and 32 byte groupchat id that were sent in the invite request.</p>
<p><a id="group-27" href="#group-27" class="paragraph">27</a>When a peer receives an invite response packet they will check if the group id sent back corresponds to the group id of the groupchat with the group number also sent back. If everything is ok, a new peer number will be generated for the peer that sent the invite response packet. Then the peer with their generated peer number, their long term public key and DHT public key will be added to the peer list of the groupchat. A new peer packet will also be sent to tell everyone in the group chat about the new peer. The peer will also be added as a temporary invited groupchat connection.</p>
<p><a id="group-28" href="#group-28" class="paragraph">28</a>Peer numbers are used to uniquely identify each peer in the group chat. They are used in groupchat message packets so that peers receiving them can know who or which groupchat peer sent them. As groupchat packets are relayed, they must contain something that is used by others to identify the sender. Since putting a 32 byte public key in each packet would be wasteful a 2 byte peer number is instead used. Each peer in the groupchat has a unique peer number. Toxcore generates each peer number randomly but makes sure newly generated peer numbers are not equal to current ones already used by other peers in the group chat. If two peers join the groupchat from two different endpoints there is a small possibility that both will be given the same peer number however this possibility is low enough in practice that is is not an issue.</p>
<p><a id="group-29" href="#group-29" class="paragraph">29</a>Temporary invited groupchat connections are groupchat connections to the groupchat inviter used by groupchat peers to bootstrap themselves the the groupchat. They are the same thing as connections to groupchat peers via friend connections except that they are discarded after the peer is fully connected to the group chat.</p>
<p><a id="group-30" href="#group-30" class="paragraph">30</a>Peer online packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x61)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number (local)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>33</code></td>
<td style="text-align: left;">Group chat identifier</td>
</tr>
</tbody>
</table>
<p><a id="group-31" href="#group-31" class="paragraph">31</a>Peer leave packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x62)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number (local)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x01)</td>
</tr>
</tbody>
</table>
<p><a id="group-32" href="#group-32" class="paragraph">32</a>For a groupchat connection to work, both peers in the groupchat must be attempting to connect directly to each other.</p>
<p><a id="group-33" href="#group-33" class="paragraph">33</a>Groupchat connections are established when both peers who want to connect to each other either create a new friend connection to connect to each other or reuse an exiting friend connection that connects them together (if they are friends or already are connected together because of another group chat).</p>
<p><a id="group-34" href="#group-34" class="paragraph">34</a>As soon as the connection to the other peer is opened, a peer online packet is sent to the peer. The goal of the online packet is to tell the peer that we want to establish the groupchat connection with them and tell them the groupchat number of our groupchat instance. The peer online packet contains the group number and the group type and 32 byte groupchat id. The group number is the group number the peer has for the group with the group id sent in the packet.</p>
<p><a id="group-35" href="#group-35" class="paragraph">35</a>When both sides send a online packet to the other peer, a connection is established.</p>
<p><a id="group-36" href="#group-36" class="paragraph">36</a>When an online packet is received, the group number to communicate with the group is saved. If the connection to the peer is already established (an online packet has been already received) then the packet is dropped. If there is no group connection to that peer being established, the packet is dropped. If this is the first group connection to that group we establish, a peer query packet is sent. This is so we can get the list of peers from the group.</p>
<p><a id="group-37" href="#group-37" class="paragraph">37</a>The peer leave packet is sent to the peer right before killing a group connection. It is only used to tell the other side that the connection is dead if the friend connection is used for other uses than the group chat (another group chat, for a connection to a friend). If not, then the other peer will see the friend connection go offline which will prompt them to stop using it and kill the group connection tied to it.</p>
<p><a id="group-38" href="#group-38" class="paragraph">38</a>Peer query packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x62)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x08)</td>
</tr>
</tbody>
</table>
<p><a id="group-39" href="#group-39" class="paragraph">39</a>Peer response packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x62)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x09)</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;"> Repeated times number of peers: Peer info</td>
</tr>
</tbody>
</table>
<p><a id="group-40" href="#group-40" class="paragraph">40</a>The Peer info structure is as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> peer number</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Long term public key</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">DHT public key</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> Name length</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>[0, 255]</code></td>
<td style="text-align: left;">Name</td>
</tr>
</tbody>
</table>
<p><a id="group-41" href="#group-41" class="paragraph">41</a>Title response packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x62)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x0a)</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Title</td>
</tr>
</tbody>
</table>
<p><a id="group-42" href="#group-42" class="paragraph">42</a>Message packets:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x63)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> peer number</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint32_t</code> message number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> with a value representing id of message</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Data</td>
</tr>
</tbody>
</table>
<p><a id="group-43" href="#group-43" class="paragraph">43</a>Lossy Message packets:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0xc7)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> group number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> peer number</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint16_t</code> message number</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> with a value representing id of message</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Data</td>
</tr>
</tbody>
</table>
<p><a id="group-44" href="#group-44" class="paragraph">44</a>If a peer query packet is received, the receiver takes his list of peers and creates a peer response packet which is then sent to the other peer. If there are too many peers in the group chat and the peer response packet would be larger than the maximum size of friend connection packets (1373 bytes), more than one peer response packet is sent back. A Title response packet is also sent back. This is how the peer that joins a group chat finds out the list of peers in the group chat and the title of the group chat right after joining.</p>
<p><a id="group-45" href="#group-45" class="paragraph">45</a>Peer response packets are straightforward and contain the information for each peer (peer number, real public key, DHT public key, name) appended to each other. The title response is also straight forward.</p>
<p><a id="group-46" href="#group-46" class="paragraph">46</a>Both the maximum length of groupchat peer names and the groupchat title is 128 bytes. This is the same maximum length as names in all of toxcore.</p>
<p><a id="group-47" href="#group-47" class="paragraph">47</a>When a peer receives the peer response packet(s), they will add each of the received peers to their groupchat peer list, find the 4 closest peers to them and create groupchat connections to them as was explained previously.</p>
<p><a id="group-48" href="#group-48" class="paragraph">48</a>To find their peer number, the peer will find themselves in the list of received peers and use the peer number assigned to them as their own.</p>
<p><a id="group-49" href="#group-49" class="paragraph">49</a>Message packets are used to send messages to all peers in the groupchat. To send a message packet, a peer will first take their peer number and the message they want to send. Each message packet sent will have a message number that is equal to the last message number sent + 1. Like all other numbers (group chat number, peer number) in the packet, the message number in the packet will be in big endian format. When a Message packet is received, the peer receiving it will take the message number in the packet and see if it is bigger than the one it has saved for the peer with peer number. If this is the first Message packet being received for this peer then this check is omitted. The message number is used to know if a Message packet was already received and relayed to prevent packets from looping around the groupchat. If the message number check says that the packet was already received, then the packet is discarded. If it was not already received, a Message packet with the message is sent (relayed) to all current group connections (normal groupchat connections + temporary invited groupchat connections) except the one that it was received from. The only thing that should change in the Message packet as it is relayed is the group number.</p>
<a href="#message-ids"><h2 id="message-ids">
<span class="header-section-number">13.1</span> Message ids</h2></a>
<a href="#ping-0x00"><h3 id="ping-0x00">
<span class="header-section-number">13.1.1</span> ping (0x00)</h3></a>
<p><a id="ping-0x00-1" href="#ping-0x00-1" class="paragraph">1</a>Sent approximately every 60 seconds by every peer. Contains no data.</p>
<a href="#new_peer-0x10"><h3 id="new_peer-0x10">
<span class="header-section-number">13.1.2</span> <code>new_peer</code> (0x10)</h3></a>
<p><a id="new_peer-0x10-1" href="#new_peer-0x10-1" class="paragraph">1</a>Tell everyone about a new peer in the chat.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> Peer number</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Long term public key</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">DHT public key</td>
</tr>
</tbody>
</table>
<a href="#kill_peer-0x11"><h3 id="kill_peer-0x11">
<span class="header-section-number">13.1.3</span> <code>kill_peer</code> (0x11)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> Peer number</td>
</tr>
</tbody>
</table>
<a href="#name-change-0x30"><h3 id="name-change-0x30">
<span class="header-section-number">13.1.4</span> Name change (0x30)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Name (namelen)</td>
</tr>
</tbody>
</table>
<a href="#groupchat-title-change-0x31"><h3 id="groupchat-title-change-0x31">
<span class="header-section-number">13.1.5</span> Groupchat title change (0x31)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Title (titlelen)</td>
</tr>
</tbody>
</table>
<a href="#chat-message-0x40"><h3 id="chat-message-0x40">
<span class="header-section-number">13.1.6</span> Chat message (0x40)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Message (messagelen)</td>
</tr>
</tbody>
</table>
<a href="#action-me-0x41"><h3 id="action-me-0x41">
<span class="header-section-number">13.1.7</span> Action (/me) (0x41)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Message (messagelen)</td>
</tr>
</tbody>
</table>
<p><a id="action-me-0x41-1" href="#action-me-0x41-1" class="paragraph">1</a>Ping messages must be sent every 60 seconds by every peer. This is how other peers know that the peers are still alive.</p>
<p><a id="action-me-0x41-2" href="#action-me-0x41-2" class="paragraph">2</a>When a new peer joins, the peer which invited the joining peer will send a new peer message to warn everyone that there is a new peer in the chat. When a new peer message is received, the peer in the packet must be added to the peer list.</p>
<p><a id="action-me-0x41-3" href="#action-me-0x41-3" class="paragraph">3</a>Kill peer messages are used to indicate that a peer has quit the group chat. It is sent by the one quitting the group chat right before they quit it.</p>
<p><a id="action-me-0x41-4" href="#action-me-0x41-4" class="paragraph">4</a>name change messages are used to change or set the name of the peer sending it. They are also sent by a joining peer right after receiving the list of peers in order to tell others what their name is.</p>
<p><a id="action-me-0x41-5" href="#action-me-0x41-5" class="paragraph">5</a>title change packets are used to change the title of the group chat and can be sent by anyone in the group chat.</p>
<p><a id="action-me-0x41-6" href="#action-me-0x41-6" class="paragraph">6</a>Chat and action messages are used by the group chat peers to send messages to others in the group chat.</p>
<p><a id="action-me-0x41-7" href="#action-me-0x41-7" class="paragraph">7</a>Lossy message packets are used to send audio packets to others in audio group chats. Lossy packets work the same way as normal relayed groupchat messages in that they are relayed to everyone in the group chat until everyone has them.</p>
<p><a id="action-me-0x41-8" href="#action-me-0x41-8" class="paragraph">8</a>Some differences with them though is that first of all the message number is a 2 byte integer. If I were to improve the groupchats protocol I would make the message number for normal message packets 2 bytes. 1 byte means only 256 packets can be received at the same time. With the delays in groupchats and 256 packets corresponding to less than a high quality video frame it would not work. This is why 2 bytes was chosen.</p>
<p><a id="action-me-0x41-9" href="#action-me-0x41-9" class="paragraph">9</a>Note that this message number like all other numbers in the packet are in big endian format.</p>
<p><a id="action-me-0x41-10" href="#action-me-0x41-10" class="paragraph">10</a>When receiving a lossy packet the peer will first check if it was already received. If it wasn’t, the packet will be added to the list of received packets and then the packet will be passed to its handler and then sent to the 2 closest connected groupchat peers that are not the sender. The reason for it to be 2 instead of 4 (well 3 if we are not the original sender) for normal message packets is that it reduces bandwidth usage without lowering the quality of the received audio stream via lossy packets. Message packets also are sent relatively rarely, enough so that changing it to 2 would have a minimal impact in bandwidth usage.</p>
<p><a id="action-me-0x41-11" href="#action-me-0x41-11" class="paragraph">11</a>To check if a packet was received, the last up to 65536 received packet numbers are stored, current groups store the last 256 packet numbers however that is because it is currently audio only. If video was added meaning a much higher number of packets would be sent, this number would be increased. If the packet number is in this list then it was received.</p>
<p><a id="action-me-0x41-12" href="#action-me-0x41-12" class="paragraph">12</a>This is how groupchats in Tox work.</p>
<a href="#net-crypto"><h1 id="net-crypto">
<span class="header-section-number">14</span> Net crypto</h1></a>
<p><a id="net-crypto-1" href="#net-crypto-1" class="paragraph">1</a>The Tox transport protocol is what Tox uses to establish and send data securely to friends and provides encryption, ordered delivery, and perfect forward secrecy. It is a UDP protocol but it is also used when 2 friends connect over TCP relays.</p>
<p><a id="net-crypto-2" href="#net-crypto-2" class="paragraph">2</a>The reason the protocol for connections to friends over TCP relays and direct UDP is the same is for simplicity and so the connection can switch between both without the peers needing to disconnect and reconnect. For example two Tox friends might first connect over TCP and a few seconds later switch to UDP when a direct UDP connection becomes possible. The opening up of the UDP route or ‘hole punching’ is done by the DHT module and the opening up of a relayed TCP connection is done by the <code>TCP_connection</code> module. The Tox transport protocol has the job of connecting two peers (tox friends) safely once a route or communications link between both is found. Direct UDP is preferred over TCP because it is direct and isn’t limited by possibly congested TCP relays. Also, a peer can only connect to another using the Tox transport protocol if they know the real public key and DHT public key of the peer they want to connect to. However, both the DHT and TCP connection modules require this information in order to find and open the route to the peer which means we assume this information is known by toxcore and has been passed to <code>net_crypto</code> when the <code>net_crypto</code> connection was created.</p>
<p><a id="net-crypto-3" href="#net-crypto-3" class="paragraph">3</a>Because this protocol has to work over UDP it must account for possible packet loss, packets arriving in the wrong order and has to implement some kind of congestion control. This is implemented above the level at which the packets are encrypted. This prevents a malicious TCP relay from disrupting the connection by modifying the packets that go through it. The packet loss prevention makes it work very well on TCP relays that we assume may go down at any time as the connection will stay strong even if there is need to switch to another TCP relay which will cause some packet loss.</p>
<p><a id="net-crypto-4" href="#net-crypto-4" class="paragraph">4</a>Before sending the actual handshake packet the peer must obtain a cookie. This cookie step serves as a way for the receiving peer to confirm that the peer initiating the connection can receive the responses in order to prevent certain types of DoS attacks.</p>
<p><a id="net-crypto-5" href="#net-crypto-5" class="paragraph">5</a>The peer receiving a cookie request packet must not allocate any resources to the connection. They will simply respond to the packet with a cookie response packet containing the cookie that the requesting peer must then use in the handshake to initiate the actual connection.</p>
<p><a id="net-crypto-6" href="#net-crypto-6" class="paragraph">6</a>The cookie response must be sent back using the exact same link the cookie request packet was sent from. The reason for this is that if it is sent back using another link, the other link might not work and the peer will not be expecting responses from another link. For example, if a request is sent from UDP with ip port X, it must be sent back by UDP to ip port X. If it was received from a TCP OOB packet it must be sent back by a TCP OOB packet via the same relay with the destination being the peer who sent the request. If it was received from an established TCP relay connection it must be sent back via that same exact connection.</p>
<p><a id="net-crypto-7" href="#net-crypto-7" class="paragraph">7</a>When a cookie request is received, the peer must not use the information in the request packet for anything, he must not store it, he must only create a cookie and cookie response from it, then send the created cookie response packet and forget them. The reason for this is to prevent possible attacks. For example if a peer would allocate long term memory for each cookie request packet received then a simple packet flood would be enough to achieve an effective denial of service attack by making the program run out of memory.</p>
<p><a id="net-crypto-8" href="#net-crypto-8" class="paragraph">8</a>cookie request packet (145 bytes):</p>
<pre><code>[uint8_t 24]
[Sender's DHT Public key (32 bytes)]
[Random nonce (24 bytes)]
[Encrypted message containing:
    [Sender's real public key (32 bytes)]
    [padding (32 bytes)]
    [uint64_t echo id (must be sent back untouched in cookie response)]
]</code></pre>
<p><a id="net-crypto-9" href="#net-crypto-9" class="paragraph">9</a>Encrypted message is encrypted with sender’s DHT private key, receiver’s DHT public key and the nonce.</p>
<p><a id="net-crypto-10" href="#net-crypto-10" class="paragraph">10</a>The packet id for cookie request packets is 24. The request contain the DHT public key of the sender which is the key used (The DHT private key) (along with the DHT public key of the receiver) to encrypt the encrypted part of the cookie packet and a nonce also used to encrypt the encrypted part of the packet. Padding is used to maintain backwards-compatibility with previous versions of the protocol. The echo id in the cookie request must be sent back untouched in the cookie response. This echo id is how the peer sending the request can be sure that the response received was a response to the packet that he sent.</p>
<p><a id="net-crypto-11" href="#net-crypto-11" class="paragraph">11</a>The reason for sending the DHT public key and real public key in the cookie request is that both are contained in the cookie sent back in the response.</p>
<p><a id="net-crypto-12" href="#net-crypto-12" class="paragraph">12</a>Toxcore currently sends 1 cookie request packet every second 8 times before it kills the connection if there are no responses.</p>
<p><a id="net-crypto-13" href="#net-crypto-13" class="paragraph">13</a>cookie response packet (161 bytes):</p>
<pre><code>[uint8_t 25]
[Random nonce (24 bytes)]
[Encrypted message containing:
    [Cookie]
    [uint64_t echo id (that was sent in the request)]
]</code></pre>
<p><a id="net-crypto-14" href="#net-crypto-14" class="paragraph">14</a>Encrypted message is encrypted with the exact same symmetric key as the cookie request packet it responds to but with a different nonce.</p>
<p><a id="net-crypto-15" href="#net-crypto-15" class="paragraph">15</a>The packet id for cookie request packets is 25. The response contains a nonce and an encrypted part encrypted with the nonce. The encrypted part is encrypted with the same key used to decrypt the encrypted part of the request meaning the expensive shared key generation needs to be called only once in order to handle and respond to a cookie request packet with a cookie response.</p>
<p><a id="net-crypto-16" href="#net-crypto-16" class="paragraph">16</a>The Cookie (see below) and the echo id that was sent in the request are the contents of the encrypted part.</p>
<p><a id="net-crypto-17" href="#net-crypto-17" class="paragraph">17</a>The Cookie should be (112 bytes):</p>
<pre><code>[nonce]
[encrypted data:
    [uint64_t time]
    [Sender's real public key (32 bytes)]
    [Sender's DHT public key (32 bytes)]
]</code></pre>
<p><a id="net-crypto-18" href="#net-crypto-18" class="paragraph">18</a>The cookie is a 112 byte piece of data that is created and sent to the requester as part of the cookie response packet. A peer who wants to connect to another must obtain a cookie packet from the peer they are trying to connect to. The only way to send a valid handshake packet to another peer is to first obtain a cookie from them.</p>
<p><a id="net-crypto-19" href="#net-crypto-19" class="paragraph">19</a>The cookie contains information that will both prove to the receiver of the handshake that the peer has received a cookie response and contains encrypted info that tell the receiver of the handshake packet enough info to both decrypt and validate the handshake packet and accept the connection.</p>
<p><a id="net-crypto-20" href="#net-crypto-20" class="paragraph">20</a>When toxcore is started it generates a symmetric encryption key that it uses to encrypt and decrypt all cookie packets (using NaCl authenticated encryption exactly like encryption everywhere else in toxcore). Only the instance of toxcore that create the packets knows the encryption key meaning any cookie it successfully decrypts and validates were created by it.</p>
<p><a id="net-crypto-21" href="#net-crypto-21" class="paragraph">21</a>The time variable in the cookie is used to prevent cookie packets that are too old from being used. Toxcore has a time out of 15 seconds for cookie packets. If a cookie packet is used more than 15 seconds after it is created toxcore will see it as invalid.</p>
<p><a id="net-crypto-22" href="#net-crypto-22" class="paragraph">22</a>When responding to a cookie request packet the sender’s real public key is the known key sent by the peer in the encrypted part of the cookie request packet and the senders DHT public key is the key used to encrypt the encrypted part of the cookie request packet.</p>
<p><a id="net-crypto-23" href="#net-crypto-23" class="paragraph">23</a>When generating a cookie to put inside the encrypted part of the handshake: One of the requirements to connect successfully to someone else is that we know their DHT public key and their real long term public key meaning there is enough information to construct the cookie.</p>
<p><a id="net-crypto-24" href="#net-crypto-24" class="paragraph">24</a>Handshake packet:</p>
<pre><code>[uint8_t 26]
[Cookie]
[nonce (24 bytes)]
[Encrypted message containing:
    [24 bytes base nonce]
    [session public key of the peer (32 bytes)]
    [sha512 hash of the entire Cookie sitting outside the encrypted part]
    [Other Cookie (used by the other to respond to the handshake packet)]
]</code></pre>
<p><a id="net-crypto-25" href="#net-crypto-25" class="paragraph">25</a>The packet id for handshake packets is 26. The cookie is a cookie obtained by sending a cookie request packet to the peer and getting a cookie response packet with a cookie in it. It may also be obtained in the handshake packet by a peer receiving a handshake packet (Other Cookie).</p>
<p><a id="net-crypto-26" href="#net-crypto-26" class="paragraph">26</a>The nonce is a nonce used to encrypt the encrypted part of the handshake packet. The encrypted part of the handshake packet is encrypted with the long term keys of both peers. This is to prevent impersonation.</p>
<p><a id="net-crypto-27" href="#net-crypto-27" class="paragraph">27</a>Inside the encrypted part of the handshake packet there is a ‘base nonce’ and a session public key. The ‘base nonce’ is a nonce that the other should use to encrypt each data packet, adding + 1 to it for each data packet sent. (first packet is ‘base nonce’ + 0, next is ‘base nonce’ + 1, etc. Note that for mathematical operations the nonce is considered to be a 24 byte number in big endian format). The session key is the temporary connection public key that the peer has generated for this connection and it sending to the other. This session key is used so that the connection has perfect forward secrecy. It is important to save the private key counterpart of the session public key sent in the handshake, the public key received by the other and both the received and sent base nonces as they are used to encrypt/decrypt the data packets.</p>
<p><a id="net-crypto-28" href="#net-crypto-28" class="paragraph">28</a>The hash of the cookie in the encrypted part is used to make sure that an attacker has not taken an older valid handshake packet and then replaced the cookie packet inside with a newer one which would be bad as they could replay it and might be able to make a mess.</p>
<p><a id="net-crypto-29" href="#net-crypto-29" class="paragraph">29</a>The ‘Other Cookie’ is a valid cookie that we put in the handshake so that the other can respond with a valid handshake without having to make a cookie request to obtain one.</p>
<p><a id="net-crypto-30" href="#net-crypto-30" class="paragraph">30</a>The handshake packet is sent by both sides of the connection. If a peer receives a handshake it will check if the cookie is valid, if the encrypted section decrypts and validates, if the cookie hash is valid, if long term public key belongs to a known friend. If all these are true then the connection is considered ‘Accepted’ but not ‘Confirmed’.</p>
<p><a id="net-crypto-31" href="#net-crypto-31" class="paragraph">31</a>If there is no existing connection to the peer identified by the long term public key to set to ‘Accepted’, one will be created with that status. If a connection to such peer with a not yet ‘Accepted’ status to exists, this connection is set to accepted. If a connection with a ‘Confirmed’ status exists for this peer, the handshake packet will be ignored and discarded (The reason for discarding it is that we do not want slightly late handshake packets to kill the connection) except if the DHT public key in the cookie contained in the handshake packet is different from the known DHT public key of the peer. If this happens the connection will be immediately killed because it means it is no longer valid and a new connection will be created immediately with the ‘Accepted’ status.</p>
<p><a id="net-crypto-32" href="#net-crypto-32" class="paragraph">32</a>Sometimes toxcore might receive the DHT public key of the peer first with a handshake packet so it is important that this case is handled and that the implementation passes the DHT public key to the other modules (DHT, <code>TCP_connection</code>) because this does happen.</p>
<p><a id="net-crypto-33" href="#net-crypto-33" class="paragraph">33</a>Handshake packets must be created only once during the connection but must be sent in intervals until we are sure the other received them. This happens when a valid encrypted data packet is received and decrypted.</p>
<p><a id="net-crypto-34" href="#net-crypto-34" class="paragraph">34</a>The states of a connection:</p>
<ol type="1">
<li>Not accepted: Send handshake packets.</li>
<li>Accepted: A handshake packet has been received from the other peer but no encrypted encrypted packets: continue (or start) sending handshake packets because the peer can’t know if the other has received them.</li>
<li>Confirmed: A valid encrypted packet has been received from the other peer: Connection is fully established: stop sending handshake packets.</li>
</ol>
<p><a id="net-crypto-35" href="#net-crypto-35" class="paragraph">35</a>Toxcore sends handshake packets every second 8 times and times out the connection if the connection does not get confirmed (no encrypted packet is received) within this time.</p>
<p><a id="net-crypto-36" href="#net-crypto-36" class="paragraph">36</a>Perfect handshake scenario:</p>
<pre><code>Peer 1                Peer 2
Cookie request   -&gt;
                      &lt;- Cookie response
Handshake packet -&gt;
                      * accepts connection
                      &lt;- Handshake packet
*accepts connection
Encrypted packet -&gt;   &lt;- Encrypted packet
*confirms connection  *confirms connection
       Connection successful.
Encrypted packets -&gt; &lt;- Encrypted packets

More realistic handshake scenario:
Peer 1                Peer 2
Cookie request   -&gt;   *packet lost*
Cookie request   -&gt;
                      &lt;- Cookie response
                      *Peer 2 randomly starts new connection to peer 1
                      &lt;- Cookie request
Cookie response  -&gt;
Handshake packet -&gt;   &lt;- Handshake packet
*accepts connection   * accepts connection
Encrypted packet -&gt;   &lt;- Encrypted packet
*confirms connection  *confirms connection
       Connection successful.
Encrypted packets -&gt; &lt;- Encrypted packets</code></pre>
<p><a id="net-crypto-37" href="#net-crypto-37" class="paragraph">37</a>The reason why the handshake is like this is because of certain design requirements:</p>
<ol type="1">
<li>The handshake must not leak the long term public keys of the peers to a possible attacker who would be looking at the packets but each peer must know for sure that they are connecting to the right peer and not an impostor.</li>
<li>A connection must be able of being established if only one of the peers has the information necessary to initiate a connection (DHT public key of the peer and a link to the peer).</li>
<li>If both peers initiate a connection to each other at the same time the connection must succeed without issues.</li>
<li>There must be perfect forward secrecy.</li>
<li>Must be resistant to any possible attacks.</li>
</ol>
<p><a id="net-crypto-38" href="#net-crypto-38" class="paragraph">38</a>Due to how it is designed only one connection is possible at a time between 2 peers.</p>
<p><a id="net-crypto-39" href="#net-crypto-39" class="paragraph">39</a>Encrypted packets:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x1b)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> The last 2 bytes of the nonce used to encrypt this</td>
</tr>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;"> Payload</td>
</tr>
</tbody>
</table>
<p><a id="net-crypto-40" href="#net-crypto-40" class="paragraph">40</a>The payload is encrypted with the session key and ‘base nonce’ set by the receiver in their handshake + packet number (starting at 0, big endian math).</p>
<p><a id="net-crypto-41" href="#net-crypto-41" class="paragraph">41</a>The packet id for encrypted packets is 27. Encrypted packets are the packets used to send data to the other peer in the connection. Since these packets can be sent over UDP the implementation must assume that they can arrive out of order or even not arrive at all.</p>
<p><a id="net-crypto-42" href="#net-crypto-42" class="paragraph">42</a>To get the key used to encrypt/decrypt each packet in the connection a peer takes the session public key received in the handshake and the private key counterpart of the key it sent it the handshake and generates a shared key from it. This shared key will be identical for both peers. It is important to note that connection keys must be wiped when the connection is killed.</p>
<p><a id="net-crypto-43" href="#net-crypto-43" class="paragraph">43</a>To create an encrypted packet to be sent to the other peer, the data is encrypted with the shared key for this connection and the base nonce that the other peer sent in the handshake packet with the total number of encrypted packets sent in the connection added to it (‘base nonce’ + 0 for the first encrypted data packet sent, ‘base nonce’ + 1 for the second, etc. Note that the nonce is treated as a big endian number for mathematical operations like additions). The 2 byte (<code>uint16_t</code>) number at the beginning of the encrypted packet is the last 2 bytes of this 24 byte nonce.</p>
<p><a id="net-crypto-44" href="#net-crypto-44" class="paragraph">44</a>To decrypt a received encrypted packet, the nonce the packet was encrypted with is calculated using the base nonce that the peer sent to the other and the 2 byte number at the beginning of the packet. First we assume that packets will most likely arrive out of order and that some will be lost but that packet loss and out of orderness will never be enough to make the 2 byte number need an extra byte. The packet is decrypted using the shared key for the connection and the calculated nonce.</p>
<p><a id="net-crypto-45" href="#net-crypto-45" class="paragraph">45</a>Toxcore uses the following method to calculate the nonce for each packet:</p>
<ol type="1">
<li>
<code>diff</code> = (2 byte number on the packet) - (last 2 bytes of the current saved base nonce) NOTE: treat the 3 variables as 16 bit unsigned ints, the result is expected to sometimes roll over.</li>
<li>copy <code>saved_base_nonce</code> to <code>temp_nonce</code>.</li>
<li>
<code>temp_nonce = temp_nonce + diff</code>. <code>temp_nonce</code> is the correct nonce that can be used to decrypt the packet.</li>
<li>
<code>DATA_NUM_THRESHOLD</code> = (1/3 of the maximum number that can be stored in an unsigned 2 bit integer)</li>
<li>if decryption succeeds and <code>diff &gt; (DATA_NUM_THRESHOLD * 2)</code> then:
<ul>
<li><code>saved_base_nonce = saved_base_nonce + DATA_NUM_THRESHOLD</code></li>
</ul>
</li>
</ol>
<p><a id="net-crypto-46" href="#net-crypto-46" class="paragraph">46</a>First it takes the difference between the 2 byte number on the packet and the last. Because the 3 values are unsigned 16 bit ints and rollover is part of the math something like diff = (10 - 65536) means diff is equal to 11.</p>
<p><a id="net-crypto-47" href="#net-crypto-47" class="paragraph">47</a>Then it copies the saved base nonce to a temp nonce buffer.</p>
<p><a id="net-crypto-48" href="#net-crypto-48" class="paragraph">48</a>Then it adds diff to the nonce (the nonce is in big endian format).</p>
<p><a id="net-crypto-49" href="#net-crypto-49" class="paragraph">49</a>After if decryption was successful it checks if diff was bigger than 2/3 of the value that can be contained in a 16 bit unsigned int and increases the saved base nonce by 1/3 of the maximum value if it succeeded.</p>
<p><a id="net-crypto-50" href="#net-crypto-50" class="paragraph">50</a>This is only one of many ways that the nonce for each encrypted packet can be calculated.</p>
<p><a id="net-crypto-51" href="#net-crypto-51" class="paragraph">51</a>Encrypted packets that cannot be decrypted are simply dropped.</p>
<p><a id="net-crypto-52" href="#net-crypto-52" class="paragraph">52</a>The reason for exchanging base nonces is because since the key for encrypting packets is the same for received and sent packets there must be a cryptographic way to make it impossible for someone to do an attack where they would replay packets back to the sender and the sender would think that those packets came from the other peer.</p>
<p><a id="net-crypto-53" href="#net-crypto-53" class="paragraph">53</a>Data in the encrypted packets:</p>
<pre><code>[our recvbuffers buffer_start, (highest packet number handled + 1), (big endian)]
[uint32_t packet number if lossless, sendbuffer buffer_end if lossy, (big endian)]
[data]</code></pre>
<p><a id="net-crypto-54" href="#net-crypto-54" class="paragraph">54</a>Encrypted packets may be lossy or lossless. Lossy packets are simply encrypted packets that are sent to the other. If they are lost, arrive in the wrong order or even if an attacker duplicates them (be sure to take this into account for anything that uses lossy packets) they will simply be decrypted as they arrive and passed upwards to what should handle them depending on the data id.</p>
<p><a id="net-crypto-55" href="#net-crypto-55" class="paragraph">55</a>Lossless packets are packets containing data that will be delivered in order by the implementation of the protocol. In this protocol, the receiver tells the sender which packet numbers he has received and which he has not and the sender must resend any packets that are dropped. Any attempt at doubling packets will cause all (except the first received) to be ignored.</p>
<p><a id="net-crypto-56" href="#net-crypto-56" class="paragraph">56</a>Each lossless packet contains both a 4 byte number indicating the highest packet number received and processed and a 4 byte packet number which is the packet number of the data in the packet.</p>
<p><a id="net-crypto-57" href="#net-crypto-57" class="paragraph">57</a>In lossy packets, the layout is the same except that instead of a packet number, the second 4 byte number represents the packet number of a lossless packet if one were sent right after. This number is used by the receiver to know if any packets have been lost. (for example if it receives 4 packets with numbers (0, 1, 2, 5) and then later a lossy packet with this second number as: 8 it knows that packets: 3, 4, 6, 7 have been lost and will request them)</p>
<p><a id="net-crypto-58" href="#net-crypto-58" class="paragraph">58</a>How the reliability is achieved:</p>
<p><a id="net-crypto-59" href="#net-crypto-59" class="paragraph">59</a>First it is important to say that packet numbers do roll over, the next number after 0xFFFFFFFF (maximum value in 4 bytes) is 0. Hence all the mathematical operations dealing with packet numbers are assumed to be done only on unsigned 32 bit integer unless said otherwise. For example 0 - 0xFFFFFFFF would equal to 1 because of the rollover.</p>
<p><a id="net-crypto-60" href="#net-crypto-60" class="paragraph">60</a>When sending a lossless packet, the packet is created with its packet number being the number of the last lossless packet created + 1 (starting at 0). The packet numbers are used for both reliability and in ordered delivery and so must be sequential.</p>
<p><a id="net-crypto-61" href="#net-crypto-61" class="paragraph">61</a>The packet is then stored along with its packet number in order for the peer to be able to send it again if the receiver does not receive it. Packets are only removed from storage when the receiver confirms they have received them.</p>
<p><a id="net-crypto-62" href="#net-crypto-62" class="paragraph">62</a>The receiver receives packets and stores them along with their packet number. When a receiver receives a packet he stores the packet along with its packet number in an array. If there is already a packet with that number in the buffer, the packet is dropped. If the packet number is smaller than the last packet number that was processed, the packet is dropped. A processed packet means it was removed from the buffer and passed upwards to the relevant module.</p>
<p><a id="net-crypto-63" href="#net-crypto-63" class="paragraph">63</a>Assuming a new connection, the sender sends 5 lossless packets to the receiver: 0, 1, 2, 3, 4 are the packet numbers sent and the receiver receives: 3, 2, 0, 2 in that order.</p>
<p><a id="net-crypto-64" href="#net-crypto-64" class="paragraph">64</a>The receiver will save the packets and discards the second packet with the number 2, he has: 0, 2, 3 in his buffer. He will pass the first packet to the relevant module and remove it from the array but since packet number 1 is missing he will stop there. Contents of the buffer are now: 2, 3. The receiver knows packet number 1 is missing and will request it from the sender by using a packet request packet:</p>
<p><a id="net-crypto-65" href="#net-crypto-65" class="paragraph">65</a>data ids:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">ID</th>
<th style="text-align: left;"> Data</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">padding (skipped until we hit a non zero (data id) byte)</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">packet request packet (lossy packet)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">connection kill packet (lossy packet)</td>
</tr>
<tr class="even">
<td style="text-align: left;">…</td>
<td style="text-align: left;">…</td>
</tr>
<tr class="odd">
<td style="text-align: left;">16+</td>
<td style="text-align: left;">reserved for Messenger usage (lossless packets)</td>
</tr>
<tr class="even">
<td style="text-align: left;">192+</td>
<td style="text-align: left;">reserved for Messenger usage (lossy packets)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">255</td>
<td style="text-align: left;">reserved for Messenger usage (lossless packet)</td>
</tr>
</tbody>
</table>
<p><a id="net-crypto-66" href="#net-crypto-66" class="paragraph">66</a>Connection kill packets tell the other that the connection is over.</p>
<p><a id="net-crypto-67" href="#net-crypto-67" class="paragraph">67</a>Packet numbers are the first byte of data in the packet.</p>
<p><a id="net-crypto-68" href="#net-crypto-68" class="paragraph">68</a>packet request packet:</p>
<pre><code>[uint8_t (1)][uint8_t num][uint8_t num][uint8_t num]...[uint8_t num]</code></pre>
<p><a id="net-crypto-69" href="#net-crypto-69" class="paragraph">69</a>Packet request packets are used by one side of the connection to request packets from the other. To create a full packet request packet, the one requesting the packet takes the last packet number that was processed (sent to the relevant module and removed from the array (0 in the example above)). Subtract the number of the first missing packet from that number (1 - 0) = 1. Which means the full packet to request packet number 1 will look like:</p>
<pre><code>[uint32_t 1]
[uint32_t 0]
[uint8_t 1][uint8_t 1]</code></pre>
<p><a id="net-crypto-70" href="#net-crypto-70" class="paragraph">70</a>If packet number 4 was being requested as well, take the difference between the packet number and the last packet number being requested (4 - 1) = 3. So the packet will look like:</p>
<pre><code>[uint32_t 1]
[uint32_t 0]
[uint8_t 1][uint8_t 1][uint8_t 3]</code></pre>
<p><a id="net-crypto-71" href="#net-crypto-71" class="paragraph">71</a>But what if the number is greater than 255? Let’s say the peer needs to request packets 3, 6, 1024, the packet will look like:</p>
<pre><code>[uint32_t 1]
[uint32_t 2]
[uint8_t 1][uint8_t 3][uint8_t 3][uint8_t 0][uint8_t 0][uint8_t 0][uint8_t 253]</code></pre>
<p><a id="net-crypto-72" href="#net-crypto-72" class="paragraph">72</a>Each 0 in the packet represents adding 255 until a non 0 byte is reached which is then added and the resulting requested number is what is left.</p>
<p><a id="net-crypto-73" href="#net-crypto-73" class="paragraph">73</a>This request is designed to be small when requesting packets in real network conditions where the requested packet numbers will be close to each other. Putting each requested 4 byte packet number would be very simple but would make the request packets unnecessarily large which is why the packets look like this.</p>
<p><a id="net-crypto-74" href="#net-crypto-74" class="paragraph">74</a>When a request packet is received, it will be decoded and all packets in between the requested packets will be assumed to be successfully received by the other.</p>
<p><a id="net-crypto-75" href="#net-crypto-75" class="paragraph">75</a>Packet request packets are sent at least every 1 second in toxcore and more when packets are being received.</p>
<p><a id="net-crypto-76" href="#net-crypto-76" class="paragraph">76</a>The current formula used is (note that this formula is likely sub-optimal):</p>
<pre><code>REQUEST_PACKETS_COMPARE_CONSTANT = 50.0 double request_packet_interval =
(REQUEST_PACKETS_COMPARE_CONSTANT /
(((double)num_packets_array(&amp;conn-&gt;recv_array) + 1.0) / (conn-&gt;packet_recv_rate
+ 1.0)));</code></pre>
<p><a id="net-crypto-77" href="#net-crypto-77" class="paragraph">77</a><code>num_packets_array(&amp;conn-&gt;recv_array)</code> returns the difference between the highest packet number received and the last one handled. In the toxcore code it refers to the total size of the current array (with the holes which are the placeholders for not yet received packets that are known to be missing).</p>
<p><a id="net-crypto-78" href="#net-crypto-78" class="paragraph">78</a><code>conn-&gt;packet_recv_rate</code> is the number of data packets successfully received per second.</p>
<p><a id="net-crypto-79" href="#net-crypto-79" class="paragraph">79</a>This formula was created with the logic that the higher the ‘delay’ in packets (<code>num_packets_array(&amp;conn-&gt;recv_array)</code>) vs the speed of packets received, the more request packets should be sent.</p>
<p><a id="net-crypto-80" href="#net-crypto-80" class="paragraph">80</a>Requested packets are resent every time they can be resent as in they will obey the congestion control and not bypass it. They are resent once, subsequent request packets will be used to know if the packet was received or if it should be resent.</p>
<p><a id="net-crypto-81" href="#net-crypto-81" class="paragraph">81</a>The ping or rtt (round trip time) between two peers can be calculated by saving the time each packet was sent and taking the difference between the time the latest packet confirmed received by a request packet was sent and the time the request packet was received. The rtt can be calculated for every request packet. The lowest one (for all packets) will be the closest to the real ping.</p>
<p><a id="net-crypto-82" href="#net-crypto-82" class="paragraph">82</a>This ping or rtt can be used to know if a request packet that requests a packet we just sent should be resent right away or we should wait or not for the next one (to know if the other side actually had time to receive the packet).</p>
<p><a id="net-crypto-83" href="#net-crypto-83" class="paragraph">83</a>The congestion control algorithm has the goal of guessing how many packets can be sent through the link every second before none can be sent through anymore. How it works is basically to send packets faster and faster until none can go through the link and then stop sending them faster than that.</p>
<p><a id="net-crypto-84" href="#net-crypto-84" class="paragraph">84</a>Currently the congestion control uses the following formula in toxcore however that is probably not the best way to do it.</p>
<p><a id="net-crypto-85" href="#net-crypto-85" class="paragraph">85</a>The current formula is to take the difference between the current size of the send queue and the size of the send queue 1.2 seconds ago, take the total number of packets sent in the last 1.2 seconds and subtract the previous number from it.</p>
<p><a id="net-crypto-86" href="#net-crypto-86" class="paragraph">86</a>Then divide this number by 1.2 to get a packet speed per second. If this speed is lower than the minimum send rate of 8 packets per second, set it to 8.</p>
<p><a id="net-crypto-87" href="#net-crypto-87" class="paragraph">87</a>A congestion event can be defined as an event when the number of requested packets exceeds the number of packets the congestion control says can be sent during this frame. If a congestion event occurred during the last 2 seconds, the packet send rate of the connection is set to the send rate previously calculated, if not it is set to that send rate times 1.25 in order to increase the speed.</p>
<p><a id="net-crypto-88" href="#net-crypto-88" class="paragraph">88</a>Like I said this isn’t perfect and a better solution can likely be found or the numbers tweaked.</p>
<p><a id="net-crypto-89" href="#net-crypto-89" class="paragraph">89</a>To fix the possible issue where it would be impossible to send very low bandwidth data like text messages when sending high bandwidth data like files it is possible to make priority packets ignore the congestion control completely by placing them into the send packet queue and sending them even if the congestion control says not to. This is used in toxcore for all non file transfer packets to prevent file transfers from preventing normal message packets from being sent.</p>
<a href="#network.txt"><h1 id="network.txt">
<span class="header-section-number">15</span> network.txt</h1></a>
<p><a id="network.txt-1" href="#network.txt-1" class="paragraph">1</a>The network module is the lowest file in toxcore that everything else depends on. This module is basically a UDP socket wrapper, serves as the sorting ground for packets received by the socket, initializes and uninitializes the socket. It also contains many socket, networking related and some other functions like a monotonic time function used by other toxcore modules.</p>
<p><a id="network.txt-2" href="#network.txt-2" class="paragraph">2</a>Things of note in this module are the maximum UDP packet size define (<code>MAX_UDP_PACKET_SIZE</code>) which sets the maximum UDP packet size toxcore can send and receive. The list of all UDP packet ids: <code>NET_PACKET_*</code>. UDP packet ids are the value of the first byte of each UDP packet and is how each packet gets sorted to the right module that can handle it. <code>networking_registerhandler()</code> is used by higher level modules in order to tell the network object which packets to send to which module via a callback.</p>
<p><a id="network.txt-3" href="#network.txt-3" class="paragraph">3</a>It also contains datastructures used for ip addresses in toxcore. IP4 and IP6 are the datastructures for ipv4 and ipv6 addresses, IP is the datastructure for storing either (the family can be set to <code>AF_INET</code> (ipv4) or <code>AF_INET6</code> (ipv6). It can be set to another value like <code>TCP_ONION_FAMILY</code>, <code>TCP_INET</code>, <code>TCP_INET6</code> or <code>TCP_FAMILY</code> which are invalid values in the network modules but valid values in some other module and denote a special type of ip) and <code>IP_Port</code> stores an IP datastructure with a port.</p>
<p><a id="network.txt-4" href="#network.txt-4" class="paragraph">4</a>Since the network module interacts directly with the underlying operating system with its socket functions it has code to make it work on windows, linux, etc… unlike most modules that sit at a higher level.</p>
<p><a id="network.txt-5" href="#network.txt-5" class="paragraph">5</a>The network module currently uses the polling method to read from the UDP socket. The <code>networking_poll()</code> function is called to read all the packets from the socket and pass them to the callbacks set using the <code>networking_registerhandler()</code> function. The reason it uses polling is simply because it was easier to write it that way, another method would be better here.</p>
<p><a id="network.txt-6" href="#network.txt-6" class="paragraph">6</a>The goal of this module is to provide an easy interface to a UDP socket and other networking related functions.</p>
<a href="#onion"><h1 id="onion">
<span class="header-section-number">16</span> Onion</h1></a>
<p><a id="onion-1" href="#onion-1" class="paragraph">1</a>The goal of the onion module in Tox is to prevent peers that are not friends from finding out the temporary DHT public key from a known long term public key of the peer and to prevent peers from discovering the long term public key of peers when only the temporary DHT key is known.</p>
<p><a id="onion-2" href="#onion-2" class="paragraph">2</a>It makes sure only friends of a peer can find it and connect to it and indirectly makes sure non friends cannot find the ip address of the peer when knowing the Tox address of the friend.</p>
<p><a id="onion-3" href="#onion-3" class="paragraph">3</a>The only way to prevent peers in the network from associating the temporary DHT public key with the long term public key is to not broadcast the long term key and only give others in the network that are not friends the DHT public key.</p>
<p><a id="onion-4" href="#onion-4" class="paragraph">4</a>The onion lets peers send their friends, whose real public key they know as it is part of the Tox ID, their DHT public key so that the friends can then find and connect to them without other peers being able to identify the real public keys of peers.</p>
<p><a id="onion-5" href="#onion-5" class="paragraph">5</a>So how does the onion work?</p>
<p><a id="onion-6" href="#onion-6" class="paragraph">6</a>The onion works by enabling peers to announce their real public key to peers by going through the onion path. It is like a DHT but through onion paths. In fact it uses the DHT in order for peers to be able to find the peers with ids closest to their public key by going through onion paths.</p>
<p><a id="onion-7" href="#onion-7" class="paragraph">7</a>In order to announce its real public key anonymously to the Tox network while using the onion, a peer first picks 3 random nodes that it knows (they can be from anywhere: the DHT, connected TCP relays or nodes found while finding peers with the onion). The nodes should be picked in a way that makes them unlikely to be operated by the same person perhaps by looking at the ip addresses and looking if they are in the same subnet or other ways. More research is needed to make sure nodes are picked in the safest way possible.</p>
<p><a id="onion-8" href="#onion-8" class="paragraph">8</a>The reason for 3 nodes is that 3 hops is what they use in Tor and other anonymous onion based networks.</p>
<p><a id="onion-9" href="#onion-9" class="paragraph">9</a>These nodes are referred to as nodes A, B and C. Note that if a peer cannot communicate via UDP, its first peer will be one of the TCP relays it is connected to, which will be used to send its onion packet to the network.</p>
<p><a id="onion-10" href="#onion-10" class="paragraph">10</a>TCP relays can only be node A or the first peer in the chain as the TCP relay is essentially acting as a gateway to the network. The data sent to the TCP Client module to be sent as a TCP onion packet by the module is different from the one sent directly via UDP. This is because it doesn’t need to be encrypted (the connection to the TCP relay server is already encrypted).</p>
<p><a id="onion-11" href="#onion-11" class="paragraph">11</a>First I will explain how communicating via onion packets work.</p>
<p><a id="onion-12" href="#onion-12" class="paragraph">12</a>Note: nonce is a 24 byte nonce. The nested nonces are all the same as the outer nonce.</p>
<p><a id="onion-13" href="#onion-13" class="paragraph">13</a>Onion packet (request):</p>
<p><a id="onion-14" href="#onion-14" class="paragraph">14</a>Initial (TCP) data sent as the data of a onion packet through the TCP client module:</p>
<ul>
<li>
<code>IP_Port</code> of node B</li>
<li>A random public key PK1</li>
<li>Encrypted with the secret key SK1 and the public key of Node B and the nonce:
<ul>
<li>
<code>IP_Port</code> of node C</li>
<li>A random public key PK2</li>
<li>Encrypted with the secret key SK2 and the public key of Node C and the nonce:
<ul>
<li>
<code>IP_Port</code> of node D</li>
<li>Data to send to Node D</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a id="onion-15" href="#onion-15" class="paragraph">15</a>Initial (UDP) (sent from us to node A):</p>
<ul>
<li>
<code>uint8_t</code> (0x80) packet id</li>
<li>Nonce</li>
<li>Our temporary DHT public key</li>
<li>Encrypted with our temporary DHT secret key and the public key of Node A and the nonce:
<ul>
<li>
<code>IP_Port</code> of node B</li>
<li>A random public key PK1</li>
<li>Encrypted with the secret key SK1 and the public key of Node B and the nonce:
<ul>
<li>
<code>IP_Port</code> of node C</li>
<li>A random public key PK2</li>
<li>Encrypted with the secret key SK2 and the public key of Node C and the nonce:
<ul>
<li>
<code>IP_Port</code> of node D</li>
<li>Data to send to Node D</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a id="onion-16" href="#onion-16" class="paragraph">16</a>(sent from node A to node B):</p>
<ul>
<li>
<code>uint8_t</code> (0x81) packet id</li>
<li>Nonce</li>
<li>A random public key PK1</li>
<li>Encrypted with the secret key SK1 and the public key of Node B and the nonce:
<ul>
<li>
<code>IP_Port</code> of node C</li>
<li>A random public key PK2</li>
<li>Encrypted with the secret key SK2 and the public key of Node C and the nonce:
<ul>
<li>
<code>IP_Port</code> of node D</li>
<li>Data to send to Node D</li>
</ul>
</li>
</ul>
</li>
<li>Nonce</li>
<li>Encrypted with temporary symmetric key of Node A and the nonce:
<ul>
<li>
<code>IP_Port</code> (of us)</li>
</ul>
</li>
</ul>
<p><a id="onion-17" href="#onion-17" class="paragraph">17</a>(sent from node B to node C):</p>
<ul>
<li>
<code>uint8_t</code> (0x82) packet id</li>
<li>Nonce</li>
<li>A random public key PK1</li>
<li>Encrypted with the secret key SK1 and the public key of Node C and the nonce:
<ul>
<li>
<code>IP_Port</code> of node D</li>
<li>Data to send to Node D</li>
</ul>
</li>
<li>Nonce</li>
<li>Encrypted with temporary symmetric key of Node B and the nonce:
<ul>
<li>
<code>IP_Port</code> (of Node A)</li>
<li>Nonce</li>
<li>Encrypted with temporary symmetric key of Node A and the nonce:
<ul>
<li>
<code>IP_Port</code> (of us)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a id="onion-18" href="#onion-18" class="paragraph">18</a>(sent from node C to node D):</p>
<ul>
<li>Data to send to Node D</li>
<li>Nonce</li>
<li>Encrypted with temporary symmetric key of Node C and the nonce:
<ul>
<li>
<code>IP_Port</code> (of Node B)</li>
<li>Nonce</li>
<li>Encrypted with temporary symmetric key of Node B and the nonce:
<ul>
<li>
<code>IP_Port</code> (of Node A)</li>
<li>Nonce</li>
<li>Encrypted with temporary symmetric key of Node A and the nonce:
<ul>
<li>
<code>IP_Port</code> (of us)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a id="onion-19" href="#onion-19" class="paragraph">19</a>Onion packet (response):</p>
<p><a id="onion-20" href="#onion-20" class="paragraph">20</a>initial (sent from node D to node C):</p>
<ul>
<li>
<code>uint8_t</code> (0x8c) packet id</li>
<li>Nonce</li>
<li>Encrypted with the temporary symmetric key of Node C and the nonce:
<ul>
<li>
<code>IP_Port</code> (of Node B)</li>
<li>Nonce</li>
<li>Encrypted with the temporary symmetric key of Node B and the nonce:
<ul>
<li>
<code>IP_Port</code> (of Node A)</li>
<li>Nonce</li>
<li>Encrypted with the temporary symmetric key of Node A and the nonce:
<ul>
<li>
<code>IP_Port</code> (of us)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Data to send back</li>
</ul>
<p><a id="onion-21" href="#onion-21" class="paragraph">21</a>(sent from node C to node B):</p>
<ul>
<li>
<code>uint8_t</code> (0x8d) packet id</li>
<li>Nonce</li>
<li>Encrypted with the temporary symmetric key of Node B and the nonce:
<ul>
<li>
<code>IP_Port</code> (of Node A)</li>
<li>Nonce</li>
<li>Encrypted with the temporary symmetric key of Node A and the nonce:
<ul>
<li>
<code>IP_Port</code> (of us)</li>
</ul>
</li>
</ul>
</li>
<li>Data to send back</li>
</ul>
<p><a id="onion-22" href="#onion-22" class="paragraph">22</a>(sent from node B to node A):</p>
<ul>
<li>
<code>uint8_t</code> (0x8e) packet id</li>
<li>Nonce</li>
<li>Encrypted with the temporary symmetric key of Node A and the nonce:
<ul>
<li>
<code>IP_Port</code> (of us)</li>
</ul>
</li>
<li>Data to send back</li>
</ul>
<p><a id="onion-23" href="#onion-23" class="paragraph">23</a>(sent from node A to us):</p>
<ul>
<li>Data to send back</li>
</ul>
<p><a id="onion-24" href="#onion-24" class="paragraph">24</a>Each packet is encrypted multiple times so that only node A will be able to receive and decrypt the first packet and know where to send it to, node B will only be able to receive that decrypted packet, decrypt it again and know where to send it and so on. You will also notice a piece of encrypted data (the sendback) at the end of the packet that grows larger and larger at every layer with the IP of the previous node in it. This is how the node receiving the end data (Node D) will be able to send data back.</p>
<p><a id="onion-25" href="#onion-25" class="paragraph">25</a>When a peer receives an onion packet, they will decrypt it, encrypt the coordinates (IP/port) of the source along with the already existing encrypted data (if it exists) with a symmetric key known only by the peer and only refreshed every hour (in toxcore) as a security measure to force expire paths.</p>
<p><a id="onion-26" href="#onion-26" class="paragraph">26</a>Here’s a diagram how it works:</p>
<pre><code>peer
  -&gt; [onion1[onion2[onion3[data]]]] -&gt; Node A
  -&gt; [onion2[onion3[data]]][sendbackA] -&gt; Node B
  -&gt; [onion3[data]][sendbackB[sendbackA]] -&gt; Node C
  -&gt; [data][SendbackC[sendbackB[sendbackA]]]-&gt; Node D (end)

Node D
  -&gt; [SendbackC[sendbackB[sendbackA]]][response] -&gt; Node C
  -&gt; [sendbackB[sendbackA]][response] -&gt; Node B
  -&gt; [sendbackA][response] -&gt; Node A
  -&gt; [response] -&gt; peer</code></pre>
<p><a id="onion-27" href="#onion-27" class="paragraph">27</a>The random public keys in the onion packets are temporary public keys generated for and used for that onion path only. This is done in order to make it difficult for others to link different paths together. Each encrypted layer must have a different public key. This is the reason why there are multiple keys in the packet definintions above.</p>
<p><a id="onion-28" href="#onion-28" class="paragraph">28</a>The nonce is used to encrypt all the layers of encryption. This 24 byte nonce should be randomly generated. If it isn’t randomly generated and has a relation to nonces used for other paths it could be possible to tie different onion paths together.</p>
<p><a id="onion-29" href="#onion-29" class="paragraph">29</a>The <code>IP_Port</code> is an ip and port in packed format:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>TOX_AF_INET</code> (2) for IPv4 or <code>TOX_AF_INET6</code> (10) for IPv6</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>4 | 16</code></td>
<td style="text-align: left;">IP address (4 bytes if IPv4, 16 if IPv6)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>12 | 0</code></td>
<td style="text-align: left;">Zeroes</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> Port</td>
</tr>
</tbody>
</table>
<p><a id="onion-30" href="#onion-30" class="paragraph">30</a>If IPv4 the format is padded with 12 bytes of zeroes so that both IPv4 and IPv6 have the same stored size.</p>
<p><a id="onion-31" href="#onion-31" class="paragraph">31</a>The <code>IP_Port</code> will always end up being of size 19 bytes. This is to make it hard to know if an ipv4 or ipv6 ip is in the packet just by looking at the size. The 12 bytes of zeros when ipv4 must be set to 0 and not left uninitialized as some info may be leaked this way if it stays uninitialized. All numbers here are in big endian format.</p>
<p><a id="onion-32" href="#onion-32" class="paragraph">32</a>The <code>IP_Port</code> in the sendback data can be in any format as long as the length is 19 bytes because only the one who writes it can decrypt it and read it, however, using the previous format is recommended because of code reuse. The nonce in the sendback data must be a 24 byte nonce.</p>
<p><a id="onion-33" href="#onion-33" class="paragraph">33</a>Each onion layers has a different packed id that identifies it so that an implementation knows exactly how to handle them. Note that any data being sent back must be encrypted, appear random and not leak information in any way as all the nodes in the path will see it.</p>
<p><a id="onion-34" href="#onion-34" class="paragraph">34</a>If anything is wrong with the received onion packets (decryption fails) the implementation should drop them.</p>
<p><a id="onion-35" href="#onion-35" class="paragraph">35</a>The implementation should have code for each different type of packet that handles it, adds (or decrypts) a sendback and sends it to the next peer in the path. There are a lot of packets but an implementation should be very straightforward.</p>
<p><a id="onion-36" href="#onion-36" class="paragraph">36</a>Note that if the first node in the path is a TCP relay, the TCP relay must put an identifier (instead of an IP/Port) in the sendback so that it knows that any response should be sent to the appropriate peer connected to the TCP relay.</p>
<p><a id="onion-37" href="#onion-37" class="paragraph">37</a>This explained how to create onion packets and how they are sent back. Next is what is actually sent and received on top of these onion packets or paths.</p>
<p><a id="onion-38" href="#onion-38" class="paragraph">38</a>Note: nonce is a 24 byte nonce.</p>
<p><a id="onion-39" href="#onion-39" class="paragraph">39</a>announce request packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x83)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">A public key (real or temporary)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">Payload</td>
</tr>
</tbody>
</table>
<p><a id="onion-40" href="#onion-40" class="paragraph">40</a>The public key is our real long term public key if we want to announce ourselves, a temporary one if we are searching for friends.</p>
<p><a id="onion-41" href="#onion-41" class="paragraph">41</a>The payload is encrypted with the secret key part of the sent public key, the public key of Node D and the nonce, and contains:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Ping ID</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public key we are searching for</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public key that we want those sending back data packets to use</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Data to send back in response</td>
</tr>
</tbody>
</table>
<p><a id="onion-42" href="#onion-42" class="paragraph">42</a>If the ping id is zero, respond with a announce response packet.</p>
<p><a id="onion-43" href="#onion-43" class="paragraph">43</a>If the ping id matches the one the node sent in the announce response and the public key matches the one being searched for, add the part used to send data to our list. If the list is full make it replace the furthest entry.</p>
<p><a id="onion-44" href="#onion-44" class="paragraph">44</a>data to route request packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x85)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public key of destination node</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Temporary just generated public key</td>
</tr>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Payload</td>
</tr>
</tbody>
</table>
<p><a id="onion-45" href="#onion-45" class="paragraph">45</a>The payload is encrypted with that temporary secret key and the nonce and the public key from the announce response packet of the destination node. If Node D contains the ret data for the node, it sends the stuff in this packet as a data to route response packet to the right node.</p>
<p><a id="onion-46" href="#onion-46" class="paragraph">46</a>The data in the previous packet is in format:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Real public key of sender</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;"> Payload</td>
</tr>
</tbody>
</table>
<p><a id="onion-47" href="#onion-47" class="paragraph">47</a>The payload is encrypted with real secret key of the sender, the nonce in the data packet and the real public key of the receiver:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> id</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;"> Data (optional)</td>
</tr>
</tbody>
</table>
<p><a id="onion-48" href="#onion-48" class="paragraph">48</a>Data sent to us:</p>
<p><a id="onion-49" href="#onion-49" class="paragraph">49</a>announce response packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x84)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Data to send back in response</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Payload</td>
</tr>
</tbody>
</table>
<p><a id="onion-50" href="#onion-50" class="paragraph">50</a>The payload is encrypted with the DHT secret key of Node D, the public key in the request and the nonce:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"> <code>uint8_t</code> <code>is_stored</code>
</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Ping ID or Public Key</td>
</tr>
<tr class="odd">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Maximum of 4 nodes in packed node format (see DHT)</td>
</tr>
</tbody>
</table>
<p><a id="onion-51" href="#onion-51" class="paragraph">51</a>The packet contains a ping ID if <code>is_stored</code> is 0 or 2, or the public key that must be used to send data packets if <code>is_stored</code> is 1.</p>
<p><a id="onion-52" href="#onion-52" class="paragraph">52</a>If the <code>is_stored</code> is not 0, it means the information to reach the public key we are searching for is stored on this node. <code>is_stored</code> is 2 as a response to a peer trying to announce himself to tell the peer that he is currently announced successfully.</p>
<p><a id="onion-53" href="#onion-53" class="paragraph">53</a>data to route response packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x86)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Temporary just generated public key</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Payload</td>
</tr>
</tbody>
</table>
<p><a id="onion-54" href="#onion-54" class="paragraph">54</a>The payload is encrypted with that temporary secret key, the nonce and the public key from the announce response packet of the destination node.</p>
<p><a id="onion-55" href="#onion-55" class="paragraph">55</a>There are 2 types of request packets and 2 ‘response’ packets to go with them. The announce request is used to announce ourselves to a node and announce response packet is used by the node to respond to this packet. The data to route request packet is a packet used to send packets through the node to another peer that has announced itself and that we have found. The data to route response packet is what the node transforms this packet into.</p>
<p><a id="onion-56" href="#onion-56" class="paragraph">56</a>To announce ourselves to the network we must first find, using announce packets, the peers with the DHT public key closest to our real public key. We must then announce ourselves to these peers. Friends will then be able to send messages to us using data to route packets by sending them to these peers. To find the peers we have announced ourselves to, our friends will find the peers closest to our real public key and ask them if they know us. They will then be able to use the peers that know us to send us some messages that will contain their DHT public key (which we need to know to connect directly to them), TCP relays that they are connected to (so we can connect to them with these relays if we need to) and some DHT peers they are connected to (so we can find them faster in the DHT).</p>
<p><a id="onion-57" href="#onion-57" class="paragraph">57</a>Announce request packets are the same packets used slightly differently if we are announcing ourselves or searching for peers that know one of our friends.</p>
<p><a id="onion-58" href="#onion-58" class="paragraph">58</a>If we are announcing ourselves we must put our real long term public key in the packet and encrypt it with our long term private key. This is so the peer we are announcing ourselves to can be sure that we actually own that public key. If we are looking for peers we use a temporary public key used only for packets looking for that peer in order to leak as little information as possible. The <code>ping_id</code> is a 32 byte number which is sent to us in the announce response and we must send back to the peer in another announce request. This is done in order to prevent people from easily announcing themselves many times as they have to prove they can respond to packets from the peer before the peer will let them announce themselves. This <code>ping_id</code> is set to 0 when none is known.</p>
<p><a id="onion-59" href="#onion-59" class="paragraph">59</a>The public key we are searching for is set to our long term public key when announcing ourselves and set to the long term public key of the friend we are searching for if we are looking for peers.</p>
<p><a id="onion-60" href="#onion-60" class="paragraph">60</a>When announcing ourselves, the public key we want others to use to send us data back is set to a temporary public key and we use the private key part of this key to decrypt packet routing data sent to us. This public key is to prevent peers from saving old data to route packets from previous sessions and be able to replay them in future Tox sessions. This key is set to zero when searching for peers.</p>
<p><a id="onion-61" href="#onion-61" class="paragraph">61</a>The sendback data is an 8 byte number that will be sent back in the announce packet response. Its goal is to be used to learn which announce request packet the response is responding to, and hence its location in the unencrypted part of the response. This is needed in toxcore to find and check info about the packet in order to decrypt it and handle it correctly. Toxcore uses it as an index to its special <code>ping_array</code>.</p>
<p><a id="onion-62" href="#onion-62" class="paragraph">62</a>Why don’t we use different packets instead of having one announce packet request and one response that does everything? It makes it a lot more difficult for possible attackers to know if we are merely announcing ourselves or if we are looking for friends as the packets for both look the same and are the same size.</p>
<p><a id="onion-63" href="#onion-63" class="paragraph">63</a>The unencrypted part of an announce response packet contains the sendback data, which was sent in the request this packet is responding to and a 24 byte random nonce used to encrypt the encrypted part.</p>
<p><a id="onion-64" href="#onion-64" class="paragraph">64</a>The <code>is_stored</code> number is set to either 0, 1 or 2. 0 means that the public key that was being searched in the request isn’t stored or known by this peer. 1 means that it is and 2 means that we are announced successfully at that node. Both 1 and 2 are needed so that when clients are restarted it is possible to reannounce without waiting for the timeout of the previous announce. This would not otherwise be possible as a client would receive response 1 without a <code>ping_id</code> which is needed in order to reannounce successfully.</p>
<p><a id="onion-65" href="#onion-65" class="paragraph">65</a>When the <code>is_stored</code> number is 0 or 2, the next 32 bytes is a <code>ping_id</code>. When <code>is_stored</code> is 1 it corresponds to a public key (the send back data public key set by the friend in their announce request) that must be used to encrypt and send data to the friend.</p>
<p><a id="onion-66" href="#onion-66" class="paragraph">66</a>Then there is an optional maximum 4 nodes, in DHT packed nodes format (see DHT), attached to the response which denote the 4 DHT peers with the DHT public keys closest to the searched public key in the announce request known by the peer (see DHT). To find these peers, toxcore uses the same function as is used to find peers for get node DHT responses. Peers wanting to announce themselves or searching for peers that ‘know’ their friends will recursively query closer and closer peers until they find the closest possible and then either announce themselves to them or just ping them every once in a while to know if their friend can be contacted. Note that the distance function used for this is the same as the Tox DHT.</p>
<p><a id="onion-67" href="#onion-67" class="paragraph">67</a>Data to route request packets are packets used to send data directly to another peer via a node that knows that peer. The public key is the public key of the final destination where we want the packet to be sent (the real public key of our friend). The nonce is a 24 byte random nonce and the public key is a random temporary public key used to encrypt the data in the packet and, if possible, only to send packets to this friend (we want to leak as little info to the network as possible so we use temp public keys as we don’t want a peer to see the same public keys and be able to link things together). The data is encrypted data that we want to send to the peer with the public key.</p>
<p><a id="onion-68" href="#onion-68" class="paragraph">68</a>The route response packets are just the last elements (nonce, public key, encrypted data) of the data to route request packet copied into a new packet and sent to the appropriate destination.</p>
<p><a id="onion-69" href="#onion-69" class="paragraph">69</a>To handle onion announce packets, toxcore first receives an announce packet and decrypts it.</p>
<p><a id="onion-70" href="#onion-70" class="paragraph">70</a>Toxcore generates <code>ping_id</code>s by taking a 32 byte sha hash of the current time, some secret bytes generated when the instance is created, the current time divided by a 20 second timeout, the public key of the requester and the source ip/port that the packet was received from. Since the ip/port that the packet was received from is in the <code>ping_id</code>, the announce packets being sent with a ping id must be sent using the same path as the packet that we received the <code>ping_id</code> from or announcing will fail.</p>
<p><a id="onion-71" href="#onion-71" class="paragraph">71</a>The reason for this 20 second timeout in toxcore is that it gives a reasonable time (20 to 40 seconds) for a peer to announce himself while taking in count all the possible delays with some extra seconds.</p>
<p><a id="onion-72" href="#onion-72" class="paragraph">72</a>Toxcore generates 2 different ping ids, the first is generated with the current time (divided by 20) and the second with the current time + 20 (divided by 20). The two ping ids are then compared to the ping ids in the received packets. The reason for doing this is that storing every ping id received might be expensive and leave us vulnerable to a DoS attack, this method makes sure that the other cannot generate <code>ping_id</code>s and must ask for them. The reason for the 2 <code>ping_id</code>s is that we want to make sure that the timeout is at least 20 seconds and cannot be 0.</p>
<p><a id="onion-73" href="#onion-73" class="paragraph">73</a>If one of the two ping ids is equal to the public key used to encrypt the announce packet (the pk the peer is announcing himself as), the sendback data public key and the sendback data are stored in the datastructure used to store announced peers. If the implementation has a limit to how many announced entries it can store, it should only store the entries closest (determined by the DHT distance function) to its DHT public key. If the entry is already there, the information will simply be updated with the new one and the timeout will be reset for that entry.</p>
<p><a id="onion-74" href="#onion-74" class="paragraph">74</a>Toxcore has a timeout of 300 seconds for announce entries after which they are removed which is long enough to make sure the entries don’t expire prematurely but not long enough for peers to stay announced for extended amounts of time after they go offline.</p>
<p><a id="onion-75" href="#onion-75" class="paragraph">75</a>Toxcore will then copy the 4 DHT nodes closest to the public key being searched to a new packet (the response).</p>
<p><a id="onion-76" href="#onion-76" class="paragraph">76</a>Toxcore will look if the public key being searched is in the datastructure. If it isn’t it will copy the first generated <code>ping_id</code> (the one generated with the current time) to the response, set the <code>is_stored</code> number to 0 and send the packet back.</p>
<p><a id="onion-77" href="#onion-77" class="paragraph">77</a>If the public key is in the datastructure, it will check whether the public key that was used to encrypt the announce packet is equal to the announced public key, if it isn’t then it means that the peer is searching for a peer and that we know it. This means the <code>is_stored</code> is set to 1 and the sending back data public key in the announce entry is copied to the packet.</p>
<p><a id="onion-78" href="#onion-78" class="paragraph">78</a>If it (key used to encrypt the announce packet) is equal (to the announced public key which is also the ‘public key we are searching for’ in the announce packet) meaning the peer is announcing itself and an entry for it exists, the sending back data public key is checked to see if it equals the one it the packet. If it is not equal it means that it is outdated, probably because the announcing peer’s toxcore instance was restarted and so their <code>is_stored</code> is set to 0, if it is equal it means the peer is announced correctly so the <code>is_stored</code> is set to 2. The first generated <code>ping_id</code> is then copied to the packet.</p>
<p><a id="onion-79" href="#onion-79" class="paragraph">79</a>Once the packet is contructed a random 24 byte nonce is generated, the packet is encrypted (the shared key used to decrypt the request can be saved and used to encrypt the response to save an expensive key derivation operation), the data to send back is copied to the unencrypted part and the packet is sent back as a onion response packet.</p>
<p><a id="onion-80" href="#onion-80" class="paragraph">80</a>In order to announce itself using onion announce packets toxcore first takes DHT peers, picks random ones and builds onion paths with them by saving 3 nodes, calling it a path, generating some keypairs for encrypting the onion packets and using them to send onion packets. If the peer is only connected with TCP, the initial nodes will be bootstrap nodes and connected TCP relays (for the first peer in the path). Once the peer is connected to the onion he can fill up his list of known peers with peers sent in announce responses if needed.</p>
<p><a id="onion-81" href="#onion-81" class="paragraph">81</a>Onion paths have different timeouts depending on whether the path is confirmed or unconfirmed. Unconfirmed paths (paths that core has never received any responses from) have a timeout of 4 seconds with 2 tries before they are deemed non working. This is because, due to network conditions, there may be a large number of newly created paths that do not work and so trying them a lot would make finding a working path take much longer. The timeout for a confirmed path (from which a response was received) is 10 seconds with 4 tries without a response. A confirmed path has a maximum lifetime of 1200 seconds to make possible deanonimization attacks more difficult.</p>
<p><a id="onion-82" href="#onion-82" class="paragraph">82</a>Toxcore saves a maximum of 12 paths: 6 paths are reserved for announcing ourselves and 6 others are used to search for friends. This may not be the safest way (some nodes may be able to associate friends together) however it is much more performant than having different paths for each friend. The main benefit is that the announcing and searching are done with different paths, which makes it difficult to know that peer with real public key X is friends with Y and Z. More research is needed to find the best way to do this. At first toxcore did have different paths for each friend, however, that meant that each friend path was almost never used (and checked). When using a low amount of paths for searching there is less resources needed to find good paths. 6 paths are used because 4 was too low and caused some performance issues because it took longer to find some good paths at the beginning because only 4 could be tried at a time. A too high number meanwhile would mean each path is used (and tested) less. The reason why the numbers are the same for both types of paths is for code simplification purposes.</p>
<p><a id="onion-83" href="#onion-83" class="paragraph">83</a>To search/announce itself to peers, toxcore keeps the 8 closest peers to each key it is searching (or announcing itself to). To populate these it starts by sending announce requests to random peers for all the public keys it is searching for. It then recursively searches closer and closer peers (DHT distance function) until it no longer finds any. It is important to make sure it is not too aggressive at searching the peers as some might no longer be online but peers might still send announce responses with their information. Toxcore keeps lists of last pinged nodes for each key searched so as not to ping dead nodes too aggressively.</p>
<p><a id="onion-84" href="#onion-84" class="paragraph">84</a>Toxcore decides if it will send an announce packet to one of the 4 peers in the announce response by checking if the peer would be stored as one of the stored 8 closest peers if it responded; if it would not be it doesn’t send a announce request, if it would be it sends one.</p>
<p><a id="onion-85" href="#onion-85" class="paragraph">85</a>Peers are only put in the 8 closest peers array if they respond to an announce request. If the peers fail to respond to 3 announce requests they are deemed timed out and removed.</p>
<p><a id="onion-86" href="#onion-86" class="paragraph">86</a>The reason for the number of peers being 8 is that a lower number might make searching for and announcing too unreliable and a higher number too bandwidth/resource intensive.</p>
<p><a id="onion-87" href="#onion-87" class="paragraph">87</a>Toxcore uses <code>ping_array</code> (see <code>ping_array</code>) for the 8 byte sendback data in announce packets to store information that it will need to handle the response (key to decrypt it, why was it sent? (to announce ourselves or to search? For what key? and some other info)). For security purposes it checks to make sure the packet was received from the right ip/port and checks if the key in the unencrypted part of the packet is the right public key.</p>
<p><a id="onion-88" href="#onion-88" class="paragraph">88</a>For peers we are announcing ourselves to, if we are not announced to them toxcore tries every 3 seconds to announce ourselves to them until they return that we have announced ourselves to, then toxcore sends an announce request packet every 15 seconds to see if we are still announced and re announce ourselves at the same time. The timeout of 15 seconds means a <code>ping_id</code> received in the last packet will not have had time to expire (20 second minimum timeout) before it is resent 15 seconds later. Toxcore sends every announce packet with the <code>ping_id</code> previously received from that peer with the same path (if possible).</p>
<p><a id="onion-89" href="#onion-89" class="paragraph">89</a>For friends this is slightly different. It is important to start searching for friends after we are fully announced. Assuming a perfect network, we would only need to do a search for friend public keys only when first starting the instance (or going offline and back online) as peers starting up after us would be able to find us immediately just by searching for us. If we start searching for friends after we are announced we prevent a scenario where 2 friends start their clients at the same time but are enable to find each other right away because they start searching for each other while they have not announced themselves.</p>
<p><a id="onion-90" href="#onion-90" class="paragraph">90</a>For this reason, after the peer is announced successfully for 17 seconds, announce packets are sent aggressively every 3 seconds to each known close peer (in the list of 8 peers) to search aggressively for peers that know the peer we are searching for.</p>
<p><a id="onion-91" href="#onion-91" class="paragraph">91</a>There are other ways this could be done and which would still work but, if making your own implementation, keep in mind that these are likely not the most optimized way to do things.</p>
<p><a id="onion-92" href="#onion-92" class="paragraph">92</a>If we find peers (more than 1) that know a friend we will send them an onion data packet with our DHT public key, up to 2 TCP relays we are connected to and 2 DHT peers close to us to help the friend connect back to us.</p>
<p><a id="onion-93" href="#onion-93" class="paragraph">93</a>Onion data packets are packets sent as the data of data to route packets.</p>
<p><a id="onion-94" href="#onion-94" class="paragraph">94</a>Onion data packets:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Long term public key of sender</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;"> Payload</td>
</tr>
</tbody>
</table>
<p><a id="onion-95" href="#onion-95" class="paragraph">95</a>The payload is encrypted with long term private key of the sender, the long term public key of the receiver and the nonce used in the data to route request packet used to send this onion data packet (shaves off 24 bytes).</p>
<p><a id="onion-96" href="#onion-96" class="paragraph">96</a>DHT public key packet:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x9c)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">
<code>uint64_t</code> <code>no_replay</code>
</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Our DHT public key</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[39, 204]</code></td>
<td style="text-align: left;">Maximum of 4 nodes in packed format</td>
</tr>
</tbody>
</table>
<p><a id="onion-97" href="#onion-97" class="paragraph">97</a>The packet will only be accepted if the <code>no_replay</code> number is greater than the <code>no_replay</code> number in the last packet received.</p>
<p><a id="onion-98" href="#onion-98" class="paragraph">98</a>The nodes sent in this packet have TCP so that the friend can connect to us.</p>
<p><a id="onion-99" href="#onion-99" class="paragraph">99</a>Why another round of encryption? We have to prove to the receiver that we own the long term public key we say we own when sending them our DHT public key. Friend requests are also sent using onion data packets but their exact format is explained in Messenger.</p>
<p><a id="onion-100" href="#onion-100" class="paragraph">100</a>The <code>no_replay</code> number is protection if someone tries to replay an older packet and should be set to an always increasing number. It is 8 bytes so you should set a high resolution monotonic time as the value.</p>
<p><a id="onion-101" href="#onion-101" class="paragraph">101</a>We send this packet every 30 seconds if there is more than one peer (in the 8) that says they our friend is announced on them. This packet can also be sent through the DHT module as a DHT request packet (see DHT) if we know the DHT public key of the friend and are looking for them in the DHT but have not connected to them yet. 30 second is a reasonable timeout to not flood the network with too many packets while making sure the other will eventually receive the packet. Since packets are sent through every peer that knows the friend, resending it right away without waiting has a high likelihood of failure as the chances of packet loss happening to all (up to to 8) packets sent is low.</p>
<p><a id="onion-102" href="#onion-102" class="paragraph">102</a>When sent as a DHT request packet (this is the data sent in the DHT request packet):</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> (0x9c)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Long term public key of sender</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
</tr>
<tr class="even">
<td style="text-align: left;">variable</td>
<td style="text-align: left;">Encrypted payload</td>
</tr>
</tbody>
</table>
<p><a id="onion-103" href="#onion-103" class="paragraph">103</a>The payload is encrypted with long term private key of sender, the long term public key of receiver and the nonce, and contains the DHT public key packet.</p>
<p><a id="onion-104" href="#onion-104" class="paragraph">104</a>When sent as a DHT request packet the DHT public key packet is (before being sent as the data of a DHT request packet) encrypted with the long term keys of both the sender and receiver and put in that format. This is done for the same reason as the double encryption of the onion data packet.</p>
<p><a id="onion-105" href="#onion-105" class="paragraph">105</a>Toxcore tries to resend this packet through the DHT every 20 seconds. 20 seconds is a reasonable resend rate which isn’t too aggressive.</p>
<p><a id="onion-106" href="#onion-106" class="paragraph">106</a>Toxcore has a DHT request packet handler that passes received DHT public key packets from the DHT module to this module.</p>
<p><a id="onion-107" href="#onion-107" class="paragraph">107</a>If we receive a DHT public key packet, we will first check if the DHT packet is from a friend, if it is not from a friend, it will be discarded. The <code>no_replay</code> will then be checked to see if it is good and no packet with a lower one was received during the session. The DHT key, the TCP nodes in the packed nodes and the DHT nodes in the packed nodes will be passed to their relevant modules. The fact that we have the DHT public key of a friend means this module has achieved its goal.</p>
<p><a id="onion-108" href="#onion-108" class="paragraph">108</a>If a friend is online and connected to us, the onion will stop all of its actions for that friend. If the peer goes offline it will restart searching for the friend as if toxcore was just started.</p>
<p><a id="onion-109" href="#onion-109" class="paragraph">109</a>If toxcore goes offline (no onion traffic for 20 seconds) toxcore will aggressively reannounce itself and search for friends as if it was just started.</p>
<a href="#ping-array"><h1 id="ping-array">
<span class="header-section-number">17</span> Ping array</h1></a>
<p><a id="ping-array-1" href="#ping-array-1" class="paragraph">1</a>Ping array is an array used in toxcore to store data for pings. It enables the storage of arbitrary data that can then be retrieved later by passing the 8 byte ping id that was returned when the data was stored. It also frees data from pings that are older than a ping expiring delay set when initializing the array.</p>
<p><a id="ping-array-2" href="#ping-array-2" class="paragraph">2</a>Ping arrays are initialized with a size and a timeout parameter. The size parameter denotes the maximum number of entries in the array and the timeout denotes the number of seconds to keep an entry in the array. Timeout and size must be bigger than 0.</p>
<p><a id="ping-array-3" href="#ping-array-3" class="paragraph">3</a>Adding an entry to the ping array will make it return an 8 byte number that can be used as the ping number of a ping packet. This number is generated by first generating a random 8 byte number (toxcore uses the cryptographic secure random number generator), dividing then multiplying it by the total size of the array and then adding the index of the element that was added. This generates a random looking number that will return the index of the element that was added to the array. This number is also stored along with the added data and the current time (to check for timeouts). Data is added to the array in a cyclical manner (0, 1, 2, 3… (array size - 1), 0, 1, …). If the array is full, the oldest element is overwritten.</p>
<p><a id="ping-array-4" href="#ping-array-4" class="paragraph">4</a>To get data from the ping array, the ping number is passed to the function to get the data from the array. The modulo of the ping number with the total size of the array will return the index at which the data is. If there is no data stored at this index, the function returns an error. The ping number is then checked against the ping number stored for this element, if it is not equal the function returns an error. If the array element has timed out, the function returns an error. If all the checks succeed the function returns the exact data that was stored and it is removed from the array.</p>
<p><a id="ping-array-5" href="#ping-array-5" class="paragraph">5</a>Ping array is used in many places in toxcore to efficiently keep track of sent packets.</p>
<a href="#state-format"><h1 id="state-format">
<span class="header-section-number">18</span> State Format</h1></a>
<p><a id="state-format-1" href="#state-format-1" class="paragraph">1</a>The reference Tox implementation uses a custom binary format to save the state of a Tox client between restarts. This format is far from perfect and will be replaced eventually. For the sake of maintaining compatibility down the road, it is documented here.</p>
<p><a id="state-format-2" href="#state-format-2" class="paragraph">2</a>The binary encoding of all integer types in the state format is a fixed-width byte sequence with the integer encoded in Little Endian unless stated otherwise.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">Zeroes</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint32_t</code> (0x15ED1B1F)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">List of sections</td>
</tr>
</tbody>
</table>
<a href="#sections"><h2 id="sections">
<span class="header-section-number">18.1</span> Sections</h2></a>
<p><a id="sections-1" href="#sections-1" class="paragraph">1</a>The core of the state format consists of a list of sections. Every section has its type and length specified at the beginning. In some cases, a section only contains one item and thus takes up the entire length of the section. This is denoted with ‘?’.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint32_t</code> Length of this section</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> Section type</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> (0x01CE)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">Section</td>
</tr>
</tbody>
</table>
<p><a id="sections-2" href="#sections-2" class="paragraph">2</a>Section types:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">NospamKeys</td>
<td style="text-align: left;">0x01</td>
</tr>
<tr class="even">
<td style="text-align: left;">DHT</td>
<td style="text-align: left;">0x02</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Friends</td>
<td style="text-align: left;">0x03</td>
</tr>
<tr class="even">
<td style="text-align: left;">Name</td>
<td style="text-align: left;">0x04</td>
</tr>
<tr class="odd">
<td style="text-align: left;">StatusMessage</td>
<td style="text-align: left;">0x05</td>
</tr>
<tr class="even">
<td style="text-align: left;">Status</td>
<td style="text-align: left;">0x06</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TcpRelays</td>
<td style="text-align: left;">0x0A</td>
</tr>
<tr class="even">
<td style="text-align: left;">PathNodes</td>
<td style="text-align: left;">0x0B</td>
</tr>
<tr class="odd">
<td style="text-align: left;">EOF</td>
<td style="text-align: left;">0xFF</td>
</tr>
</tbody>
</table>
<p><a id="sections-3" href="#sections-3" class="paragraph">3</a>Not every section listed above is required to be present in order to restore from a state file. Only NospamKeys is required.</p>
<a href="#nospam-and-keys-0x01"><h3 id="nospam-and-keys-0x01">
<span class="header-section-number">18.1.1</span> Nospam and Keys (0x01)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint32_t</code> Nospam</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Long term public key</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Long term secret key</td>
</tr>
</tbody>
</table>
<a href="#dht-0x02"><h3 id="dht-0x02">
<span class="header-section-number">18.1.2</span> DHT (0x02)</h3></a>
<p><a id="dht-0x02-1" href="#dht-0x02-1" class="paragraph">1</a>This section contains a list of DHT-related sections.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint32_t</code> (0x159000D)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">List of DHT sections</td>
</tr>
</tbody>
</table>
<a href="#dht-sections"><h4 id="dht-sections">
<span class="header-section-number">18.1.2.1</span> DHT Sections</h4></a>
<p><a id="dht-sections-1" href="#dht-sections-1" class="paragraph">1</a>Every DHT section has the following structure:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint32_t</code> Length of this section</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> DHT section type</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> (0x11CE)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">DHT section</td>
</tr>
</tbody>
</table>
<p><a id="dht-sections-2" href="#dht-sections-2" class="paragraph">2</a>DHT section types:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Nodes</td>
<td style="text-align: left;">0x04</td>
</tr>
</tbody>
</table>
<h5 id="nodes-0x04">
<span class="header-section-number">18.1.2.1.1</span> Nodes (0x04)</h5>
<p><a id="nodes-0x04-1" href="#nodes-0x04-1" class="paragraph">1</a>This section contains a list of nodes. These nodes are used to quickly reconnect to the DHT after a Tox client is restarted.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">List of nodes</td>
</tr>
</tbody>
</table>
<p><a id="nodes-0x04-2" href="#nodes-0x04-2" class="paragraph">2</a>The structure of a node is the same as <code>Node Info</code>. Note: this means that the integers stored in these nodes are stored in Big Endian as well.</p>
<a href="#friends-0x03"><h3 id="friends-0x03">
<span class="header-section-number">18.1.3</span> Friends (0x03)</h3></a>
<p><a id="friends-0x03-1" href="#friends-0x03-1" class="paragraph">1</a>This section contains a list of friends. A friend can either be a peer we’ve sent a friend request to or a peer we’ve accepted a friend request from.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">List of friends</td>
</tr>
</tbody>
</table>
<p><a id="friends-0x03-2" href="#friends-0x03-2" class="paragraph">2</a>Friend:</p>
<p><a id="friends-0x03-3" href="#friends-0x03-3" class="paragraph">3</a>Some of the integers in this structure are stored in Big Endian. This is denoted with “(BE)”.</p>
<p><a id="friends-0x03-4" href="#friends-0x03-4" class="paragraph">4</a>Unfortunately, toxcore copies the friend structure directly from memory to the state file. This makes the state format platform dependent because the way a structure is laid out in memory differs across platforms and compilers. A common layout of this structure in memory (GCC on x86 and x86_64) is described below and should be accounted for both when serializing and deserializing the state file.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> Status</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Long term public key</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1024</code></td>
<td style="text-align: left;">Friend request message as a UTF-8 encoded string</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> Size of the friend request message (BE)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>128</code></td>
<td style="text-align: left;">Name as a UTF-8 encoded string</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> Size of the name (BE)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1007</code></td>
<td style="text-align: left;">Status message as a UTF-8 encoded string</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">
<code>uint16_t</code> Size of the status message (BE)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> User status (see also: <code>USERSTATUS</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>3</code></td>
<td style="text-align: left;">PADDING</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>4</code></td>
<td style="text-align: left;">
<code>uint32_t</code> Nospam (only used for sending a friend request)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">
<code>uint64_t</code> Last seen time</td>
</tr>
</tbody>
</table>
<p><a id="friends-0x03-5" href="#friends-0x03-5" class="paragraph">5</a>Status can be one of:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Status</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">Not a friend</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">Friend added</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">Friend request sent</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">Confirmed friend</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">Friend online</td>
</tr>
</tbody>
</table>
<a href="#name-0x04"><h3 id="name-0x04">
<span class="header-section-number">18.1.4</span> Name (0x04)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">Name as a UTF-8 encoded string</td>
</tr>
</tbody>
</table>
<a href="#status-message-0x05"><h3 id="status-message-0x05">
<span class="header-section-number">18.1.5</span> Status Message (0x05)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">Status message as a UTF-8 encoded string</td>
</tr>
</tbody>
</table>
<a href="#status-0x06"><h3 id="status-0x06">
<span class="header-section-number">18.1.6</span> Status (0x06)</h3></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">
<code>uint8_t</code> User status (see also: <code>USERSTATUS</code>)</td>
</tr>
</tbody>
</table>
<a href="#tcp-relays-0x0a"><h3 id="tcp-relays-0x0a">
<span class="header-section-number">18.1.7</span> Tcp Relays (0x0A)</h3></a>
<p><a id="tcp-relays-0x0a-1" href="#tcp-relays-0x0a-1" class="paragraph">1</a>This section contains a list of TCP relays.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">List of TCP relays</td>
</tr>
</tbody>
</table>
<p><a id="tcp-relays-0x0a-2" href="#tcp-relays-0x0a-2" class="paragraph">2</a>The structure of a TCP relay is the same as <code>Node Info</code>. Note: this means that the integers stored in these nodes are stored in Big Endian as well.</p>
<a href="#path-nodes-0x0b"><h3 id="path-nodes-0x0b">
<span class="header-section-number">18.1.8</span> Path Nodes (0x0B)</h3></a>
<p><a id="path-nodes-0x0b-1" href="#path-nodes-0x0b-1" class="paragraph">1</a>This section contains a list of path nodes used for onion routing.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">List of path nodes</td>
</tr>
</tbody>
</table>
<p><a id="path-nodes-0x0b-2" href="#path-nodes-0x0b-2" class="paragraph">2</a>The structure of a path node is the same as <code>Node Info</code>. Note: this means that the integers stored in these nodes are stored in Big Endian as well.</p>
<a href="#eof-0xff"><h3 id="eof-0xff">
<span class="header-section-number">18.1.9</span> EOF (0xFF)</h3></a>
<p><a id="eof-0xff-1" href="#eof-0xff-1" class="paragraph">1</a>This section indicates the end of the state file. This section doesn’t have any content and thus it’s length is 0.</p>
<a href="#test-protocol"><h1 id="test-protocol">
<span class="header-section-number">19</span> Test protocol</h1></a>
<p><a id="test-protocol-1" href="#test-protocol-1" class="paragraph">1</a>The test framework consists of a model implementation and a test runner. A “system under test” (SUT) is a protocol implementation that is tested by the test runner. The SUT is presented to the test runner as a standalone executable that communicates with it using pipes.</p>
<p><a id="test-protocol-2" href="#test-protocol-2" class="paragraph">2</a>The test runner and SUT both implement the binary test protocol.</p>
<p><a id="test-protocol-3" href="#test-protocol-3" class="paragraph">3</a>The test input is a length-prefixed test name and an arbitrary piece of data. The meaning of that data depends on the test name.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>$length</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;">Bytes</td>
<td style="text-align: left;">Payload</td>
</tr>
</tbody>
</table>
<a href="#basic-data-encoding"><h2 id="basic-data-encoding">
<span class="header-section-number">19.1</span> Basic data encoding</h2></a>
<p><a id="basic-data-encoding-1" href="#basic-data-encoding-1" class="paragraph">1</a>The test protocol uses a limited and well-defined set of types. Their binary encodings are specified here.</p>
<p><a id="basic-data-encoding-2" href="#basic-data-encoding-2" class="paragraph">2</a>In the <code>BinaryDecode</code> and <code>BinaryEncode</code> tests, the test name is followed by a data format name. The test runner will run both the decode and encode tests for each data format listed here.</p>
<p><a id="basic-data-encoding-3" href="#basic-data-encoding-3" class="paragraph">3</a>All lists are encoded as 64 bit length (big endian encoded) followed by each element concatenated. List is a parameterised type and as such is not used in tests directly.</p>
<p><a id="basic-data-encoding-4" href="#basic-data-encoding-4" class="paragraph">4</a><code>String</code>: Strings are lists of bytes containing the UTF-8 encoded code points making up the string.</p>
<p><a id="basic-data-encoding-5" href="#basic-data-encoding-5" class="paragraph">5</a><code>ByteString</code>: A ByteString is a list of 8 bit bytes.</p>
<p><a id="basic-data-encoding-6" href="#basic-data-encoding-6" class="paragraph">6</a><code>Word32</code> is a 32 bit unsigned integer that is encoded in big endian.</p>
<p><a id="basic-data-encoding-7" href="#basic-data-encoding-7" class="paragraph">7</a><code>NodeInfo</code>: Node Info is encoded in the <a href="#node-info-packed-node-format">packed node format</a>.</p>
<a href="#deconstructed-values"><h2 id="deconstructed-values">
<span class="header-section-number">19.2</span> Deconstructed values</h2></a>
<p><a id="deconstructed-values-1" href="#deconstructed-values-1" class="paragraph">1</a>Deconstructed values are used to test binary decoding and encoding capabilities of the implementation. To avoid simple echo implementations, the binary representation of a deconstructed value of complex types is usually different from the usual packet encoding. A deconstructed value contains sufficient information to construct a value.</p>
<p><a id="deconstructed-values-2" href="#deconstructed-values-2" class="paragraph">2</a>An isomorphism exists between the deconstructed value and the constructed value.</p>
<p><a id="deconstructed-values-3" href="#deconstructed-values-3" class="paragraph">3</a>The <code>construct</code> function shows how a value is constructed from its components. By default, there is no special construction, so the construct function is the identity function.</p>
<p><a id="deconstructed-values-4" href="#deconstructed-values-4" class="paragraph">4</a>The <code>deconstruct</code> function produces the separate components from a constructed value. Similarly to the construct function, the default deconstruct function is the identity function.</p>
<p><a id="deconstructed-values-5" href="#deconstructed-values-5" class="paragraph">5</a>The types <code>Word32</code>, <code>String</code>, and <code>ByteString</code> have no special deconstructed type and are just used as-is.</p>
<a href="#deconstructed-node-info"><h3 id="deconstructed-node-info">
<span class="header-section-number">19.2.1</span> Deconstructed: Node Info</h3></a>
<p><a id="deconstructed-node-info-1" href="#deconstructed-node-info-1" class="paragraph">1</a>The deconstructed Node Info value is a simple serialisation of each field, without packing the protocol and address family into the same byte using magic values.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Field</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Length</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>is_tcp</code></td>
<td style="text-align: left;"><code>Bool</code></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>is_ipv6</code></td>
<td style="text-align: left;"><code>Bool</code></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IP address</td>
<td style="text-align: left;"><code>Bytes</code></td>
<td style="text-align: left;">4 for IPv4, 16 for IPv6</td>
</tr>
<tr class="even">
<td style="text-align: left;">Port number</td>
<td style="text-align: left;"><code>Word16</code></td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Public key</td>
<td style="text-align: left;"><code>Bytes</code></td>
<td style="text-align: left;">32</td>
</tr>
</tbody>
</table>
<p><a id="deconstructed-node-info-2" href="#deconstructed-node-info-2" class="paragraph">2</a>The transport protocol flag (<code>is_tcp</code>) is <code>False</code> (0x00) for UDP or <code>True</code> (0x01) for TCP. The address family flag is <code>False</code> for IPv4 or <code>True</code> for IPv6.</p>
<a href="#test-names"><h2 id="test-names">
<span class="header-section-number">19.3</span> Test names</h2></a>
<p><a id="test-names-1" href="#test-names-1" class="paragraph">1</a>Each test has a name that is used to identify the test so the rest of the input message (the payload) can be interpreted correctly.</p>
<a href="#test-failure-test"><h3 id="test-failure-test">
<span class="header-section-number">19.3.1</span> Test: Failure Test</h3></a>
<p><a id="test-failure-test-1" href="#test-failure-test-1" class="paragraph">1</a>This test receives no data and returns no data, but expects the test to always fail.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>11</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "FailureTest"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;">0</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">No data</td>
</tr>
</tbody>
</table>
<a href="#test-success-test"><h3 id="test-success-test">
<span class="header-section-number">19.3.2</span> Test: Success Test</h3></a>
<p><a id="test-success-test-1" href="#test-success-test-1" class="paragraph">1</a>This test always succeeds, also with no data.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>11</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "SuccessTest"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;">0</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">No data</td>
</tr>
</tbody>
</table>
<a href="#test-skipped-test"><h3 id="test-skipped-test">
<span class="header-section-number">19.3.3</span> Test: Skipped Test</h3></a>
<p><a id="test-skipped-test-1" href="#test-skipped-test-1" class="paragraph">1</a>This test must be skipped, also with no data. If the SUT always returns Success or Failure, the test fails.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>11</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "SkippedTest"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;">0</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">No data</td>
</tr>
</tbody>
</table>
<a href="#test-binary-decode"><h3 id="test-binary-decode">
<span class="header-section-number">19.3.4</span> Test: Binary Decode</h3></a>
<p><a id="test-binary-decode-1" href="#test-binary-decode-1" class="paragraph">1</a>Checks whether the SUT can correctly decode values and produce the deconstructed value.</p>
<p><a id="test-binary-decode-2" href="#test-binary-decode-2" class="paragraph">2</a>Input:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>12</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "BinaryDecode"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;">Bytes</td>
<td style="text-align: left;">Binary encoding of value</td>
</tr>
</tbody>
</table>
<p><a id="test-binary-decode-3" href="#test-binary-decode-3" class="paragraph">3</a>This test is parameterised by a <a href="#basic-data-encoding">data format</a>. The data format is part of the test name string. The test name “BinaryDecode” is followed by a space and the data format name (e.g. <code>"Word32"</code>, <code>"NodeInfo"</code>, …). Thus, the actual length is <code>12 + 1 + n</code> where <code>n</code> is the length of the data format name. The actual test name is then for example <code>"BinaryDecode NodeInfo"</code>. Every data format listed in the binary data encoding section is tested in both BinaryDecode and BinaryEncode.</p>
<p><a id="test-binary-decode-4" href="#test-binary-decode-4" class="paragraph">4</a>Not all binary encodings in the Tox protocol are self-delimiting, so an explicit length is prefixed to the bytes containing the binary encoding of the value.</p>
<p><a id="test-binary-decode-5" href="#test-binary-decode-5" class="paragraph">5</a>Output: The binary encoding of the <a href="#deconstructed-values">deconstructed value</a> in a <a href="#success-result">Success</a> message. On decoding failure, this test must return <a href="#failure-result">Failure</a>. If the SUT incorrectly determines that the byte array was a correct encoding of the data type, the test fails.</p>
<a href="#test-binary-encode"><h3 id="test-binary-encode">
<span class="header-section-number">19.3.5</span> Test: Binary Encode</h3></a>
<p><a id="test-binary-encode-1" href="#test-binary-encode-1" class="paragraph">1</a>Checks whether the SUT can correctly encode values given its constituent parts. This test is similar to the Binary Decode test, but receives the components the value is made of, instead of the encoded value itself.</p>
<p><a id="test-binary-encode-2" href="#test-binary-encode-2" class="paragraph">2</a>Input:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>12</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "BinaryEncode"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;">Bytes</td>
<td style="text-align: left;">Binary encoding of deconstructed value</td>
</tr>
</tbody>
</table>
<p><a id="test-binary-encode-3" href="#test-binary-encode-3" class="paragraph">3</a>Like <a href="#test-binary-decode">Binary Decode</a>, this test is also parameterised by <a href="#basic-data-encoding">data format</a>.</p>
<p><a id="test-binary-encode-4" href="#test-binary-encode-4" class="paragraph">4</a>All binary encodings of deconstructed values are self-delimiting, so an explicit length is not passed here.</p>
<p><a id="test-binary-encode-5" href="#test-binary-encode-5" class="paragraph">5</a>Output: The encoded value in a <a href="#success-result">Success</a> message, not length-prefixed.</p>
<a href="#test-distance"><h3 id="test-distance">
<span class="header-section-number">19.3.6</span> Test: Distance</h3></a>
<p><a id="test-distance-1" href="#test-distance-1" class="paragraph">1</a>Checks whether the xor-distance metric works correctly.</p>
<p><a id="test-distance-2" href="#test-distance-2" class="paragraph">2</a>Input:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "Distance"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Origin key</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Alice key</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Bob key</td>
</tr>
</tbody>
</table>
<p><a id="test-distance-3" href="#test-distance-3" class="paragraph">3</a>Output:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>Tag</code></td>
<td style="text-align: left;">0x01 (Success)</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">Ordering</td>
<td style="text-align: left;">Less, Equal, or Greater</td>
</tr>
</tbody>
</table>
<p><a id="test-distance-4" href="#test-distance-4" class="paragraph">4</a>The ordering value is encoded as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Encoding</th>
<th style="text-align: left;">When</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Less</td>
<td style="text-align: left;">0x00</td>
<td style="text-align: left;">distance(Origin, Alice) &lt; distance(Origin, Bob)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Equal</td>
<td style="text-align: left;">0x01</td>
<td style="text-align: left;">the distances are equal</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Greater</td>
<td style="text-align: left;">0x02</td>
<td style="text-align: left;">distance(Origin, Alice) &gt; distance(Origin, Bob).</td>
</tr>
</tbody>
</table>
<a href="#test-nonce-increment"><h3 id="test-nonce-increment">
<span class="header-section-number">19.3.7</span> Test: Nonce Increment</h3></a>
<p><a id="test-nonce-increment-1" href="#test-nonce-increment-1" class="paragraph">1</a>Checks whether the function to increment a nonce works correctly.</p>
<p><a id="test-nonce-increment-2" href="#test-nonce-increment-2" class="paragraph">2</a>Input: A 24-byte nonce.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>14</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "NonceIncrement"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
<td style="text-align: left;">Base nonce</td>
</tr>
</tbody>
</table>
<p><a id="test-nonce-increment-3" href="#test-nonce-increment-3" class="paragraph">3</a>Output:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>Tag</code></td>
<td style="text-align: left;">0x01 (Success)</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>24</code></td>
<td style="text-align: left;">Nonce</td>
<td style="text-align: left;">Base nonce + 1</td>
</tr>
</tbody>
</table>
<a href="#test-k-bucket-index"><h3 id="test-k-bucket-index">
<span class="header-section-number">19.3.8</span> Test: K-Bucket Index</h3></a>
<p><a id="test-k-bucket-index-1" href="#test-k-bucket-index-1" class="paragraph">1</a>Checks whether the K-bucket index is computed correctly.</p>
<p><a id="test-k-bucket-index-2" href="#test-k-bucket-index-2" class="paragraph">2</a>Input: Two public keys for Self and Other.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>12</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "KBucketIndex"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Base key</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Node key</td>
</tr>
</tbody>
</table>
<p><a id="test-k-bucket-index-3" href="#test-k-bucket-index-3" class="paragraph">3</a>Output: either <code>Nothing</code> or <code>Just i</code> in a <a href="#success-result">Success</a> message.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Value</th>
<th style="text-align: left;">When</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;">0x00</td>
<td style="text-align: left;">Base key == Node key: <code>Nothing</code>
</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>2</code></td>
<td style="text-align: left;">0x01, <code>i</code>
</td>
<td style="text-align: left;">otherwise: <code>Just i</code>
</td>
</tr>
</tbody>
</table>
<p><a id="test-k-bucket-index-4" href="#test-k-bucket-index-4" class="paragraph">4</a>The value of <code>i</code> is the k-bucket index of the Node key in a k-buckets instance with the given Base key.</p>
<a href="#test-k-bucket-nodes"><h3 id="test-k-bucket-nodes">
<span class="header-section-number">19.3.9</span> Test: K-Bucket Nodes</h3></a>
<p><a id="test-k-bucket-nodes-1" href="#test-k-bucket-nodes-1" class="paragraph">1</a>Input:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of name</td>
</tr>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>12</code></td>
<td style="text-align: left;">Message Kind</td>
<td style="text-align: left;">Test name: "KBucketNodes"</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Bucket size (k)</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>32</code></td>
<td style="text-align: left;">Public Key</td>
<td style="text-align: left;">Base key</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;">[Node Info]</td>
<td style="text-align: left;">Added nodes</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;">[Public Key]</td>
<td style="text-align: left;">Removed node keys</td>
</tr>
</tbody>
</table>
<p><a id="test-k-bucket-nodes-2" href="#test-k-bucket-nodes-2" class="paragraph">2</a>The base key is the DHT public key of the simulated node. The added nodes is a list of nodes to consecutively add to the K-buckets. The removed nodes is a list of keys for which to consecutively remove the nodes from the K-buckets after adding all nodes from the added nodes list.</p>
<p><a id="test-k-bucket-nodes-3" href="#test-k-bucket-nodes-3" class="paragraph">3</a>Node Info is encoded with the packet node format. Recall that all lists are prefixed with a 64 bit length encoded in big endian.</p>
<p><a id="test-k-bucket-nodes-4" href="#test-k-bucket-nodes-4" class="paragraph">4</a>Output: A list of all nodes in the K-buckets.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="packet-row outer-layer">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>Tag</code></td>
<td style="text-align: left;">0x01 (Success)</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;">Int</td>
<td style="text-align: left;">Length of node list</td>
</tr>
<tr class="packet-row">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;">[Node Info]</td>
<td style="text-align: left;">The node list</td>
</tr>
</tbody>
</table>
<a href="#result"><h2 id="result">
<span class="header-section-number">19.4</span> Result</h2></a>
<p><a id="result-1" href="#result-1" class="paragraph">1</a>The Result type is written to stdout by the SUT. It is a single byte for Failure (0x00), Success (0x01), and Skipped (0x02), followed by the result data.</p>
<a href="#failure-result"><h3 id="failure-result">
<span class="header-section-number">19.4.1</span> Failure Result</h3></a>
<p><a id="failure-result-1" href="#failure-result-1" class="paragraph">1</a>In case of error, a <code>Failure</code> message is returned with an UTF-8 encoded failure message.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>Tag</code></td>
<td style="text-align: left;">0x00 (Failure)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>8</code></td>
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;">length</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>$length</code></td>
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;">error message</td>
</tr>
</tbody>
</table>
<a href="#success-result"><h3 id="success-result">
<span class="header-section-number">19.4.2</span> Success Result</h3></a>
<p><a id="success-result-1" href="#success-result-1" class="paragraph">1</a>In case of success, a <code>Success</code> message with an arbitrary piece of data is returned, depending on the test name in the input.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>Tag</code></td>
<td style="text-align: left;">0x01 (Success)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[0,]</code></td>
<td style="text-align: left;"><code>Bytes</code></td>
<td style="text-align: left;">Payload</td>
</tr>
</tbody>
</table>
<a href="#skipped-result"><h3 id="skipped-result">
<span class="header-section-number">19.4.3</span> Skipped Result</h3></a>
<p><a id="skipped-result-1" href="#skipped-result-1" class="paragraph">1</a>Tests can be skipped by returning a <code>Skipped</code> message. These tests will be ignored and reported as successful.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Length</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>Tag</code></td>
<td style="text-align: left;">0x02 (Skipped)</td>
</tr>
</tbody>
</table>
<p><a id="skipped-result-2" href="#skipped-result-2" class="paragraph">2</a>All tests are ran with randomly generated inputs. The test runner has a <code>--seed</code> parameter to set the random seed to a fixed value. This helps make tests reproducible.</p>
      

    </div>
  </body>
</html>
